/*This souvrce code copyrighted by Lazy Foo' Productions (2004-2020)
and may not be redistributed without written permission.*/

/*

THIS IS IT :
->>>> // https://codereview.stackexchange.com/questions/41086/play-some-sine-waves-with-sdl2


 https://docs.huihoo.com/sdl/sdl-1.0-intro-en/usingsound.html
   http://wiki.libsdl.org/SDL_AudioSpec
  https://gist.github.com/armornick/3447121


  https://stackoverflow.com/questions/10110905/simple-sound-wave-generator-with-sdl-in-c
  https://stackoverflow.com/questions/10110905/simple-sound-wave-generator-with-sdl-in-c


  https://web.archive.org/web/20120313055436/http://www.dgames.org/beep-sound-with-sdl/

  https://github.com/jakebesworth/Simple-SDL2-Audio
  https://soundprogramming.net/programming/tutorial-using-sdl2-and-sdl_mixer-to-play-samples/
 http://forums.libsdl.org/viewtopic.php?p=13939
  https://forums.libsdl.org/viewtopic.php?p=34218

  migration : https://wiki.libsdl.org/MigrationGuide
  https://moddb.fandom.com/wiki/SDL_mixer:Tutorials:Playing_a_WAV_Sound_File




http://turrier.fr/articles/3d-03/programmation-3d-avec-codeblocks-et-opengl.php

http://www.lirmm.fr/~bosio/HMEE104/win_help_code_block.pdf

http://www.sci.brooklyn.cuny.edu/~goetz/codeblocks/glut/

https://www.codewithc.com/how-to-setup-sdl-in-codeblocks/

http://forums.codeblocks.org/index.php?topic=15719.0

https://github.com/Emilieczq/Paint-tool

https://stackoverflow.com/questions/21890627/drawing-a-rectangle-with-sdl2

https://stackoverflow.com/questions/35398586/how-do-i-draw-a-transparent-or-semi-transparent-rectangle-on-top-of-an-opaque-on
 */

//Using SDL and standard IO
#include <SDL.h>
#include <SDL_image.h>
#include <SDL_ttf.h>
#include <SDL_mixer.h>

#include <stdio.h>
#include <tchar.h>
#include <vector>
#include <time.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <iostream>
#include <windows.h>
#include <mmsystem.h>
#include <fstream>
#include <cmath>

using namespace std;

#define BUFSIZE MAX_PATH


// ZONE 02 ?


// DECLARATIONS

Uint32 getpixel(SDL_Surface *surface, int x, int y) ;

// AUDIO

const double ChromaticRatio = 1.059463094359295264562;
const double Tao =  2 * M_PI;

Uint32 sampleRate = 48000;
Uint32 frameRate =    60;
Uint32 floatStreamLength = 1024;// must be a power of two, decrease to allow for a lower syncCompensationFactor to allow for lower latency, increase to reduce risk of underrun
Uint32 samplesPerFrame; // = sampleRate/frameRate;
Uint32 msPerFrame; // = 1000/frameRate;
double practicallySilent = 0.001;

Uint32 audioBufferLength = 48000;// must be a multiple of samplesPerFrame (auto adjusted upwards if not)
float *audioBuffer;

SDL_atomic_t audioCallbackLeftOff;
Sint32 audioMainLeftOff;
Uint8 audioMainAccumulator;

SDL_AudioDeviceID AudioDevice;
SDL_AudioSpec audioSpec;

SDL_Event event;
SDL_bool running = SDL_TRUE;


//Screen dimension constants
const int SCREEN_WIDTH = 1600; // 2400
const int SCREEN_HEIGHT = 1000 ; // 1600

int masque [SCREEN_WIDTH][SCREEN_HEIGHT] = {0} ;

int blowUpSelectaX = 20 ;
int blowUpSelectaY = 20 * SCREEN_HEIGHT / SCREEN_WIDTH ;

const int maxX = SCREEN_WIDTH  ;
const int maxY = SCREEN_HEIGHT ;

UINT32 image[maxX][maxY] = {0};

bool autoSave = true ;

const int sizeColorPick = 16 ;
char colorPick[sizeColorPick][sizeColorPick][sizeColorPick] = {0};

const double PI = M_PI ;

string newMode = "";
int  minimumW = 0 ;
int minimumH = 0 ;

int fillPixel  = 8 ;  // faire varier avec une commande 1 à 16

int  countdownChangeAll = 2000 ;
int changeAll = 200 ;


int expand = 4 ;
int delayExpand = 50 ;

bool transpa = false ;
int transpaR = 0 ;
int transpaG = 0 ;
int transpaB = 0 ;

int pragmaticalMaxX = maxX ;
int pragmaticalMaxY = maxY ;

int freqSymetries = 100 ;
int freqDuplicates = 500 ;

int    fixSpacingx= 1 ;
int                   fixSpacingy = 1 ;

int nextImage = 100, nextImageVariation = 100, changeImage = 100 ;

string ChosenFile ;
long oldValue, newValue = 0 ;
bool foundImage = false ;
bool symetries = false ;

char mode = 's' ;
char page = '0' ;
int attente = 1 ;
int basicW = 100, basicH = 100, variationX = 1, variationY = 1  ;
bool modeChess = false ;
bool modeRandomChanger = false ;

long number ;

long totalFilesNumber ;
long partialFilesNumber ;

//Starts up SDL and creates window
bool init();

//Loads media
bool loadMedia();

//Frees media and shuts down SDL
void close();

//The window we'll be rendering to
SDL_Window* gWindow = NULL;

//The surface contained by the window
SDL_Surface* gScreenSurface = NULL;
SDL_Surface* screenCopy = NULL ;

//The image we will load and show on the screen
SDL_Surface* gHelloWorld = NULL;



typedef struct
{
    float *waveform;
    Uint32 waveformLength;
    double volume;        // multiplied
    double pan;           // 0 to 1: all the way left to all the way right
    double frequency;     // Hz
    double phase;         // 0 to 1
} voice;



//The music that will be played
Mix_Music *gMusic = NULL;

//The sound effects that will be used
Mix_Chunk *gScratch = NULL;
Mix_Chunk *gHigh = NULL;
Mix_Chunk *gMedium = NULL;
Mix_Chunk *gLow = NULL;


#define NUM_SOUNDS 2

struct sample
{
    Uint8 *data;
    Uint32 dpos;
    Uint32 dlen;
} sounds[NUM_SOUNDS];


void speak(voice *v)
{
    float sample;
    Uint32 sourceIndex;
    double phaseIncrement = v->frequency/sampleRate;
    Uint32 i;
    if (v->volume > practicallySilent)
    {
        for (i=0; (i+1)<samplesPerFrame; i+=2)
        {

            v->phase += phaseIncrement;
            if (v->phase > 1)
                v->phase -= 1;

            sourceIndex = v->phase*v->waveformLength;
            sample = v->waveform[sourceIndex]*v->volume;

            audioBuffer[audioMainLeftOff+i] += sample*(1-v->pan); //left channel
            audioBuffer[audioMainLeftOff+i+1] += sample*v->pan;   //right channel
        }
    }
    else
    {
        for (i=0; i<samplesPerFrame; i+=1)
            audioBuffer[audioMainLeftOff+i] = 0;
    }
    audioMainAccumulator++;
}

double getFrequency(double pitch)
{
    return pow(ChromaticRatio, pitch-57)*440;
}

int getWaveformLength(double pitch)
{
    return 2 * sampleRate / getFrequency(pitch)+0.5f;
}

void buildSineWave(float *data, Uint32 length)
{
    Uint32 i;
    for (i=0; i < length; i++)
        data[i] = sin( i*(Tao/length) );
    // data[i] = sin( rand()%100 );

}

void buildPixelWave(float *data, Uint32 length)
{
    Uint32 i;
    Uint32 j ;

    for (i=1; i < length; i++)

    {
        int m = i / maxX ;
        int n = ( i - ( m * maxX )) % maxY ; // TODO à vérifier ailleurs ! probable bug multiple
        // cout << "c";

        j =  getpixel(
                 gScreenSurface,
                 m,
                 n )   ;

        // cout << "g" ;

        float k = (float) j / (float) 0xFFFFFF ;

        //  cout << "d" ;
        if ( k > 1 )
        {
            k = 1 ;
        }
        if ( k < -1 )
        {
            k = -1 ;
        }

        data[i] = k ;
    }

// cout << "succes build" << endl ;


    /// !!!!! getpixel n'est pas GetPixel !!!!
    // data[i] = sin( rand()%100 );

}



void logSpec(SDL_AudioSpec *as)
{
    printf(
        " freq______%5d\n"
        " format____%5d\n"
        " channels__%5d\n"
        " silence___%5d\n"
        " samples___%5d\n"
        " size______%5d\n\n",
        (int) as->freq,
        (int) as->format,
        (int) as->channels,
        (int) as->silence,
        (int) as->samples,
        (int) as->size
    );
}

void logVoice(voice *v)
{
    printf(
        " waveformLength__%d\n"
        " volume__________%f\n"
        " pan_____________%f\n"
        " frequency_______%f\n"
        " phase___________%f\n",
        v->waveformLength,
        v->volume,
        v->pan,
        v->frequency,
        v->phase
    );
}

void logWavedata(float *floatStream, Uint32 floatStreamLength, Uint32 increment)
{
    printf("\n\nwaveform data:\n\n");
    Uint32 i=0;
    for (i=0; i<floatStreamLength; i+=increment)
        printf("%4d:%2.16f\n", i, floatStream[i]);
    printf("\n\n");
}

void audioCallback(void *unused, Uint8 *byteStream, int byteStreamLength)
{
    float* floatStream = (float*) byteStream;

    Sint32 localAudioCallbackLeftOff = SDL_AtomicGet(&audioCallbackLeftOff);

    Uint32 i;
    for (i=0; i<floatStreamLength; i++)
    {

        floatStream[i] = audioBuffer[localAudioCallbackLeftOff];

        localAudioCallbackLeftOff++;
        if ( localAudioCallbackLeftOff == audioBufferLength )
            localAudioCallbackLeftOff = 0;
    }
    //printf("localAudioCallbackLeftOff__%5d\n", localAudioCallbackLeftOff);

    SDL_AtomicSet(&audioCallbackLeftOff, localAudioCallbackLeftOff);
}




void mixaudio(void *unused, Uint8 *stream, int len)
{
    int i;
    Uint32 amount;

    for ( i=0; i<NUM_SOUNDS; ++i )
    {
        amount = (sounds[i].dlen-sounds[i].dpos);
        if ( amount > len )
        {
            amount = len;
        }
        SDL_MixAudio(stream, &sounds[i].data[sounds[i].dpos], amount, SDL_MIX_MAXVOLUME);
        sounds[i].dpos += amount;
    }
}

// VIDEO
SDL_Surface    *texte = NULL, *imageDeFond = NULL, *impactImage = NULL, *impactCopy = NULL ;
SDL_Rect positionFond, positionimpact;


TCHAR Buffer[BUFSIZE];
TCHAR pathToAnalyze[BUFSIZE];
TCHAR initialPath[BUFSIZE];
TCHAR veryInitialPath[BUFSIZE];


typedef struct searchList searchList ;
struct searchList
{
    string nom ;
    long nombre ;
} ;

searchList item ;
vector <searchList> maListe ;

typedef struct points points ;
struct points
{
    int x ;
    int y ;
};

vector <points> zonePoints;

inline void wait_on_enter()
{
    std::string dummy;
    std::cout << std::endl << "Enter to continue..." << std::endl;
    std::getline(std::cin, dummy);
    cout << endl << endl ;
}

TCHAR convert[BUFSIZE];



void PlayZone ( )
{
    int index;
    SDL_AudioSpec wave;
    Uint8 *data;
    Uint32 dlen;
    SDL_AudioCVT cvt;

    /* Look for an empty (or finished) sound slot */
    for ( index=0; index<NUM_SOUNDS; ++index )
    {
        if ( sounds[index].dpos == sounds[index].dlen )
        {
            cout << "found slot " << index << endl ;
            break;
        }
    }
    if ( index == NUM_SOUNDS )
    {
        cout << endl << "no slot " << endl ;
        SDL_Delay(1000);
        return;
    }


    /* Load the pixel zone and convert it to 16-bit stereo at 22kHz
    if ( SDL_LoadWAV(file, &wave, &data, &dlen) == NULL ) {
        fprintf(stderr, "Couldn't load %s: %s\n", file, SDL_GetError());
        return;
    }
    */


    Uint32 dataPixel[120-100][120-100] = {0} ;
    Uint32 pixel ;

    for (int i = 100 ; i < 120 ; i++ )
    {
        for (int j = 100 ; j < 120 ; j++ )
        {
            pixel = getpixel(gScreenSurface,i,j);
            dataPixel[i-100][j-100] = pixel   ;
            cout << dataPixel[i-100][j-100] << " " ;
        }
    }


    cout << " a " << endl ;
    SDL_BuildAudioCVT(&cvt, AUDIO_F32, 2, 44100, AUDIO_S16, 2, 44100);
    cout << " b " << endl ;
    SDL_assert(cvt.needed); // obviously, this one is always needed.
    cout << " c " << endl ;
    cvt.len = (120-100) * ( 120-100) * 2 * 4;  // 1024 stereo float32 sample frames.
    cout << " d " << endl ;
    cvt.buf = (Uint8 *) SDL_malloc(cvt.len * cvt.len_mult);
    cout << " e " << endl ;
// read your float32 data into cvt.buf here.
// SDL_ConvertAudio(&cvt);
    cout << " f " << endl ;
// cvt.buf has cvt.len_cvt bytes of converted data now.


    //  cvt.buf = ( Uint8*) malloc(dlen*cvt.len_mult);

    // cvt.buf est le buffer dans lequel on doit copier le data issu des pixels

    dlen = ( 120- 100 ) * ( 120 - 100 ) * 4 ;

    memcpy(cvt.buf, dataPixel, dlen);
    cout << " g " << endl ;
    cvt.len = dlen;
    SDL_ConvertAudio(&cvt);
    cout << " h " << endl ;
    // SDL_FreeWAV(data);
    cout << " i " << endl ;

    /* Put the sound data in the slot (it starts playing immediately) */
    if ( sounds[index].data )
    {
        free(sounds[index].data);
    }
    SDL_LockAudio();
    cout << " j " << endl ;
    sounds[index].data = cvt.buf;
    sounds[index].dlen = cvt.len_cvt;
    sounds[index].dpos = 0;
    SDL_UnlockAudio();
    cout << " k " << endl ;
}





bool init()
{
    //Initialization flag
    bool success = true;

    //Initialize SDL
    if( SDL_Init( SDL_INIT_VIDEO ) < 0 )
    {
        printf( "SDL could not initialize! SDL_Error: %s\n", SDL_GetError() );
        success = false;
    }
    else
    {
        //Create window
        gWindow = SDL_CreateWindow( "uQitll-ty6", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN );
        if( gWindow == NULL )
        {
            printf( "Window could not be created! SDL_Error: %s\n", SDL_GetError() );
            success = false;
        }
        else
        {
            //Get window surface
            gScreenSurface = SDL_GetWindowSurface( gWindow );
        }
    }

    SDL_Init(SDL_INIT_AUDIO | SDL_INIT_TIMER);

    SDL_AudioSpec want;

    SDL_zero(want);// btw, I have no idea what this is...

    want.freq = sampleRate;
    want.format = AUDIO_F32;
    want.channels = 2;
    want.samples = floatStreamLength;
    want.callback = audioCallback;

    AudioDevice = SDL_OpenAudioDevice(NULL, 0, &want, &audioSpec, SDL_AUDIO_ALLOW_FORMAT_CHANGE);

    if (AudioDevice == 0)
    {
        printf("\nFailed to open audio: %s\n", SDL_GetError());
        return 1;
    }

    printf("want:\n");
    logSpec(&want);
    printf("audioSpec:\n");
    logSpec(&audioSpec);

    if (audioSpec.format != want.format)
    {
        printf("\nCouldn't get Float32 audio format.\n");
        return 2;
    }

    sampleRate = audioSpec.freq;
    floatStreamLength = audioSpec.size/4;
    samplesPerFrame = sampleRate/frameRate;
    msPerFrame = 1000/frameRate;
    audioMainLeftOff = samplesPerFrame*8;
    SDL_AtomicSet(&audioCallbackLeftOff, 0);

    if (audioBufferLength % samplesPerFrame)
        audioBufferLength += samplesPerFrame-(audioBufferLength % samplesPerFrame);
    audioBuffer = (float*) malloc( sizeof(float)*audioBufferLength );


    return success;
}

bool loadMedia()
{
    //Loading success flag
    bool success = true;

    //Load splash image
    gHelloWorld = IMG_Load( "hello_world.bmp" );
    if( gHelloWorld == NULL )
    {
        printf( "Unable to load image %s! SDL Error: %s\n", "02_getting_an_image_on_the_screen/hello_world.bmp", SDL_GetError() );
        success = false;
    }

    return success;
}

void close()
{
    //Deallocate surface
    SDL_FreeSurface( gHelloWorld );
    gHelloWorld = NULL;

    //Destroy window
    SDL_DestroyWindow( gWindow );
    gWindow = NULL;

    SDL_CloseAudioDevice(AudioDevice);
    free(audioBuffer);//not necessary?

    //Quit SDL subsystems
    SDL_Quit();
}

void stringToConvert(string str )
{
    int i = 0 ;
    for( i=0; i<str.length(); i++)
    {
        convert[i] = str[i];
    }
    convert[i]= 0 ;
    return ;
}

void ajouteItem(string look)
/** \brief rajoute un type de fichiers dont il faut se souvenir dans la recherche récursive des folders
 *
 * \param un string qui décrit ce qu'il faut chercher exactement, ex ".jPg" - peu importe caps
 * \return rien
 *
 */

{
    stringToConvert(look);

    int i = look.length();
    for ( int a = 0 ; a < i ; a++ )
    {
        convert[a] = tolower(convert[a]);
    }

    look = convert ;

    item.nom = look ;
    item.nombre = 0 ;
    maListe.push_back(item);
}


void resetListCounters ()
{
    for ( int i = 0 ; i < maListe.size() ; i++ )
    {
        maListe[i].nombre = 0  ;
    }
    //  maListe.clear();
}

long calculTotalFoundListFiles ()
{
    long somme = 0 ;
    for ( int i = 0 ; i < maListe.size() ; i++ )
    {
        somme += maListe[i].nombre  ;
    }
    return somme ;
}

insertTabs(int a )
{
    for ( int i = 0 ; i <a ; i++)
    {
        cout << "  ";
    }
}

void explicitTotalList(   TCHAR*  pathToAnalyze,  int level )
/** \brief va lister complètement le folder : tous les fichiers
 *
 * \param folder initial
 * \param valeur de level
 * \return
 *
 */

{
    HANDLE            hFind;
    WIN32_FIND_DATA   ffd;
    DWORD dwError=0;
    WIN32_FIND_DATA   FindFileData;

    LARGE_INTEGER     filesize;
    TCHAR             szDir[MAX_PATH];
    size_t            length_of_arg;

    TCHAR internalToAnalyze[BUFSIZE];
    strcpy(internalToAnalyze,pathToAnalyze);
    strcat (internalToAnalyze,"\\*");

    hFind = FindFirstFile(internalToAnalyze, &ffd);

    if (INVALID_HANDLE_VALUE == hFind)
    {
        return ;
     //   return dwError;
    }

    do
    {
        if (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            string nomDuRepertoire = ffd.cFileName;

            if ( nomDuRepertoire == "." || nomDuRepertoire == ".." )
            {

                insertTabs(level );
                //   cout << level << ":" ;

                cout << nomDuRepertoire << endl ;
            }
            else
            {
                insertTabs(level);
                // cout << level << ":" ;
                cout << ffd.cFileName ;
                // _tprintf(TEXT("%s \n"), ffd.cFileName);
                cout << " <DIR>" << endl ;

                TCHAR recurseToAnalyze[BUFSIZE];
                strcpy(recurseToAnalyze,pathToAnalyze);
                strcat (recurseToAnalyze,"\\");
                stringToConvert(nomDuRepertoire);
                strcat (recurseToAnalyze,convert);

                //     analyzePath(recurseToAnalyze,  level + 1 ) ;
                explicitTotalList(recurseToAnalyze,  level + 1 ) ;

            }
        }
        else
        {
            filesize.LowPart = ffd.nFileSizeLow;
            filesize.HighPart = ffd.nFileSizeHigh;

            ++totalFilesNumber ;

            string Name = ffd.cFileName ;

            stringToConvert(Name);

            int i = Name.length();
            for ( int a = 0 ; a < i ; a++ )
            {
                convert[a] = tolower(convert[a]);
            }

            Name = convert ;

            insertTabs(level);
            // cout << level << ":" ;
            // _tprintf(TEXT("%s %ld bytes\n"), ffd.cFileName, filesize.QuadPart);
            cout << ffd.cFileName << " " << filesize.QuadPart ;

            for ( int i = 0 ; i < maListe.size() ; i++ )
            {
                // cout << maListe[i].nom << " = " << maListe[i].nombre << endl ;
                int found = Name.find(maListe[i].nom);
                if (found!=std::string::npos)
                {
                    maListe[i].nombre++;
                    cout << " " ;
                    //   SetConsoleTextAttribute(hConsole, 28);
                    cout << "*"  ;
                    //  SetConsoleTextAttribute(hConsole, 12 );
                }
            }

            cout << endl ;

        }
    }
    while (FindNextFile(hFind, &ffd) != 0);

    dwError = GetLastError();
    if (dwError != ERROR_NO_MORE_FILES)
    {
        //  DisplayErrorBox(TEXT("FindFirstFile"));
    }

    FindClose(hFind);
}


bool foundName = false ;
string fullNameSearched = "" ;

void giveNameOfSearchedFileNumber (   TCHAR*  pathToAnalyze,  int level, long searched )
{

    if ( level == 0 )
    {
        foundName = false ;
    }

    HANDLE            hFind;
    WIN32_FIND_DATA   ffd;
    DWORD dwError=0;
    WIN32_FIND_DATA   FindFileData;

    LARGE_INTEGER     filesize;
    TCHAR             szDir[MAX_PATH];
    size_t            length_of_arg;

    TCHAR internalToAnalyze[BUFSIZE];
    strcpy(internalToAnalyze,pathToAnalyze);
    strcat (internalToAnalyze,"\\*");

    hFind = FindFirstFile(internalToAnalyze, &ffd);

    if (INVALID_HANDLE_VALUE == hFind)
    {
        //   return dwError;
    }

    do
    {
        if (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            string nomDuRepertoire = ffd.cFileName;

            if ( nomDuRepertoire == "." || nomDuRepertoire == ".." )
            {

                //  insertTabs(level );
                //   cout << level << ":" ;

                //  cout << nomDuRepertoire << endl ;
            }
            else
            {
                //  insertTabs(level);
                // cout << level << ":" ;
                //  cout << ffd.cFileName ;
                // _tprintf(TEXT("%s \n"), ffd.cFileName);
                // cout << " <DIR>" << endl ;

                TCHAR recurseToAnalyze[BUFSIZE];
                strcpy(recurseToAnalyze,pathToAnalyze);
                strcat (recurseToAnalyze,"\\");
                stringToConvert(nomDuRepertoire);
                strcat (recurseToAnalyze,convert);

                //     analyzePath(recurseToAnalyze,  level + 1 ) ;
                giveNameOfSearchedFileNumber (recurseToAnalyze,  level + 1, searched ) ;
                if ( foundName )
                {
                    return ;
                }
            }
        }
        else
        {
            filesize.LowPart = ffd.nFileSizeLow;
            filesize.HighPart = ffd.nFileSizeHigh;

            ++totalFilesNumber ;

            string Name = ffd.cFileName ;

            stringToConvert(Name);

            int i = Name.length();
            for ( int a = 0 ; a < i ; a++ )
            {
                convert[a] = tolower(convert[a]);
            }

            Name = convert ;

            //  insertTabs(level);
            // cout << level << ":" ;
            // _tprintf(TEXT("%s %ld bytes\n"), ffd.cFileName, filesize.QuadPart);
// cout << ffd.cFileName << " " << filesize.QuadPart ;

            for ( int i = 0 ; i < maListe.size() ; i++ )
            {
                // cout << maListe[i].nom << " = " << maListe[i].nombre << endl ;
                int found = Name.find(maListe[i].nom);
                if (found!=std::string::npos)
                {
                    maListe[i].nombre++;
                    if ( partialFilesNumber == searched )
                    {

                        TCHAR recurseToAnalyze[BUFSIZE];
                        strcpy(recurseToAnalyze,pathToAnalyze);
                        strcat (recurseToAnalyze,"\\");
                        stringToConvert(Name);
                        strcat (recurseToAnalyze,convert);
                        Name = recurseToAnalyze ;

                        fullNameSearched = Name ;
                        foundName = true ;
                        return ;
                    }

                    partialFilesNumber++ ;
                    // cout << " " ;
                    // SetConsoleTextAttribute(hConsole, 28);
                    // cout << "*"  ;
                    //  SetConsoleTextAttribute(hConsole, 12 );
                }
            }

            // cout << endl ;

        }
    }
    while (FindNextFile(hFind, &ffd) != 0 && foundName == false );

    dwError = GetLastError();
    if (dwError != ERROR_NO_MORE_FILES)
    {
        //  DisplayErrorBox(TEXT("FindFirstFile"));
    }

    FindClose(hFind);
}


// https://www.libsdl.org/release/SDL-1.2.15/docs/html/guidevideo.html

/*
 * Return the pixel value at (x, y)
 * NOTE: The surface must be locked before calling this!
 */
Uint32 getpixel(SDL_Surface *surface, int x, int y)
{
    int bpp = surface->format->BytesPerPixel;
    /* Here p is the address to the pixel we want to retrieve */
    Uint8 *p = (Uint8 *)surface->pixels + y * surface->pitch + x * bpp;

    switch(bpp)
    {
    case 1:
        return *p;

    case 2:
        return *(Uint16 *)p;

    case 3:
        if(SDL_BYTEORDER == SDL_BIG_ENDIAN)
            return p[0] << 16 | p[1] << 8 | p[2];
        else
            return p[0] | p[1] << 8 | p[2] << 16;

    case 4:
        return *(Uint32 *)p;

    default:
        return 0;       /* shouldn't happen, but avoids warnings */
    }
}


void putpixel(SDL_Surface *surface, int x, int y, Uint32 pixel)
{
    int bpp = surface->format->BytesPerPixel;
    /* Here p is the address to the pixel we want to set */
    Uint8 *p = (Uint8 *)surface->pixels + y * surface->pitch + x * bpp;

    switch(bpp)
    {
    case 1:
        *p = pixel;
        break;

    case 2:
        *(Uint16 *)p = pixel;
        break;

    case 3:
        if(SDL_BYTEORDER == SDL_BIG_ENDIAN)
        {
            p[0] = (pixel >> 16) & 0xff;
            p[1] = (pixel >> 8) & 0xff;
            p[2] = pixel & 0xff;
        }
        else
        {
            p[0] = pixel & 0xff;
            p[1] = (pixel >> 8) & 0xff;
            p[2] = (pixel >> 16) & 0xff;
        }
        break;

    case 4:
        *(Uint32 *)p = pixel;
        break;
    }
}

Uint32 mixPixelA_B( Uint32 pixelA, Uint32 pixelB, int ratio )
/** \brief mélange 2 pixels selon un ratio
 *
 * \param pixel1
 * \param pixel2
 * \param ratio sur 255 : 0 = complètement B ; 255 = complètement A
 * \return nouveau pixel
 *
 */

{
    Uint32 temporaire ;
    Uint32 pixAU = ( pixelA >> 24 ) & 0xFF ;
    Uint32 pixARed = ( pixelA >> 16 ) & 0xFF ;
    Uint32 pixAGreen = ( pixelA >> 8 ) & 0xFF ;
    Uint32 pixABlue = ( pixelA >> 0 ) & 0xFF ;

    Uint32 pixBU = ( pixelB >> 24 ) & 0xFF ;
    Uint32 pixBRed = ( pixelB >> 16 ) & 0xFF ;
    Uint32 pixBGreen = ( pixelB >> 8 ) & 0xFF ;
    Uint32 pixBBlue = ( pixelB >> 0 ) & 0xFF ;

    Uint32 resultU = ( pixAU * ratio + pixBU * ( 255 - ratio ) ) / (  255 ) ;
    Uint32 resultRed =  ( pixARed * ratio + pixBRed * ( 255 - ratio ) ) / (  255 ) ;
    Uint32 resultGreen =   ( pixAGreen* ratio + pixBGreen * ( 255 - ratio ) ) / (  255 ) ;
    Uint32 resultBlue =   ( pixABlue* ratio + pixBBlue* ( 255 - ratio ) ) / (  255 ) ;

    Uint32 final = (resultU << 24 ) + ( resultRed << 16 ) + ( resultGreen << 8 ) +  ( resultBlue << 0 ) ;

    return final ;
}



void ownBlit ( SDL_Surface* impact, Sint16  x, Sint16   y, Sint16  w, Sint16  h,
               SDL_Surface* ecran, Sint16  tgtx, Sint16 tgty,
               int transparence, int typeDegrade = 0  )
{
    int impactW = impact->w ;
    int impactH = impact->h ;
    for ( Sint16 i = x ; i < ( x+w) ; i++ )
    {
        if ( i < impactW )
        {
            for ( Sint16  j = y ; j < ( y+h ); j++ )
            {
                if ( j < impactH )
                {
                    Uint32 pixel = getpixel(impact,i,j);

                    Sint16 newTgtX = tgtx + i - x ;
                    Sint16 newTgtY = tgty + j - y ;
                    if ( newTgtX < maxX && newTgtY < maxY )
                    {
                        Uint32 killR = (( pixel >>( 16 ) ) & 0xFF ) / ( 256 / sizeColorPick )  ;
                        Uint32 killG = (( pixel >>( 8 ) )  & 0xFF ) / ( 256 / sizeColorPick) ;
                        Uint32 killB = (( pixel >>( 0 ) )  & 0xFF ) / ( 256 / sizeColorPick ) ;

                        if ( colorPick[killR][killG][killB] == 0 )
                        {
                            Uint32 pixelEcran = getpixel(gScreenSurface,newTgtX,newTgtY);
                            Uint32 melange = mixPixelA_B(pixelEcran,pixel,transparence);

                            if ( typeDegrade == 1 )
                            {
                                int transparenceLocale = ( transparence * ( j - y ) ) / ( h ) ;
                                melange = mixPixelA_B(pixelEcran,pixel,transparenceLocale);
                            }

                            putpixel(gScreenSurface,newTgtX,newTgtY,melange);
                        }
                    }
                }
                else
                {
                    j = y+h ;
                }
            }
        }
        else
        {
            i = x+w ;
        }
    }
}

void saveWAVcomplete ( string name )     // doit déjà contenir .wav
{
    int n = name.length();

    // declaring character array
    char char_array[n+1];

    // copying the contents of the
    // string to char array
    strcpy(char_array, name.c_str());

    ofstream fichier(char_array, ios::out | ios::trunc);  // ouverture en écriture avec effacement du fichier ouvert

    if(fichier)
    {
        {
            fichier << ("RIFF");

            // 4 bytes pour décrire la taille - 8
            // calcul de la taille : maxX * maxY, chacun 24 bits, soit 3 bytes
            // donc à priori : ce nombre, +44, -8 ;
            UINT32 lengthOfFormatData = 16 ;
            UINT32 lengthOfFormatData_ = lengthOfFormatData ;
            UINT32 typeOfFormat = 1 ; // PCM
            UINT32 numberOfChannel = 2 ; // PCM
            UINT32 numberOfChannel_ = numberOfChannel ; // PCM
            UINT32 repeatRec = rand()%4 + 1 ;

            repeatRec = 1 ;

            UINT32 sampleRate = 44100 ; // 44100
            UINT32 sampleRate_ = sampleRate  ; // 44100


            UINT32 tailleFichier = ((UINT32) maxX * (UINT32)maxY  * ( lengthOfFormatData_ / 8 ) * numberOfChannel_ * repeatRec ) + (UINT32)44 -(UINT32) 8 ;  // mais attention, on doit l'écrire en LITTLE ENDIAN

            fichier << (byte) ( tailleFichier & 0xFF ) ;
            tailleFichier = tailleFichier >> 8 ;
            fichier << (byte)( tailleFichier & 0xFF ) ;
            tailleFichier = tailleFichier >> 8 ;
            fichier << (byte)( tailleFichier & 0xFF ) ;
            tailleFichier = tailleFichier >> 8 ;
            fichier << (byte)( tailleFichier & 0xFF  );

            fichier << "WAVE" ;

            // CHUNK ID
            fichier << "fmt " ; // trailing NULL à la fin - dans certaines pages, mentionnen un 0x20, càd SPACE

            // CHUNK BODY SIZE  ???


            fichier << (byte) ( lengthOfFormatData & 0xFF ) ;
            lengthOfFormatData = lengthOfFormatData >> 8 ;
            fichier << (byte) ( lengthOfFormatData & 0xFF ) ;
            lengthOfFormatData= lengthOfFormatData >> 8 ;
            fichier << (byte) ( lengthOfFormatData & 0xFF ) ;
            lengthOfFormatData = lengthOfFormatData >> 8 ;
            fichier << (byte) ( lengthOfFormatData & 0xFF ) ;

            // 21-22	1	Type of format (1 is PCM) - 2 byte integer
            // Format Code	2	16-bit unsigned integer

            fichier << (byte) ( typeOfFormat & 0xFF ) ;
            typeOfFormat = typeOfFormat >> 8 ;
            fichier << (byte) ( typeOfFormat & 0xFF ) ;

            // 23-24	2	Number of Channels - 2 byte integer
            // Number of Channels	2	16-bit unsigned integer


            fichier << (byte) ( numberOfChannel & 0xFF ) ;
            numberOfChannel = numberOfChannel >> 8 ;
            fichier << (byte) ( numberOfChannel & 0xFF ) ;

            // 25-28	44100	Sample Rate - 32 byte integer. Common values are 44100 (CD), 48000 (DAT). Sample Rate = Number of Samples per second, or Hertz.
            // Samples per second	4	32-bit unsigned integer

            fichier << (byte) ( sampleRate  & 0xFF ) ;
            sampleRate  = sampleRate >> 8 ;
            fichier << (byte) ( sampleRate  & 0xFF ) ;
            sampleRate  = sampleRate >> 8 ;
            fichier << (byte) ( sampleRate  & 0xFF ) ;
            sampleRate  = sampleRate >> 8 ;
            fichier << (byte) ( sampleRate  & 0xFF ) ;

            // 29-32	176400	(Sample Rate * BitsPerSample * Channels) / 8.
            // Bytes per Second (a.k.a byte rate)	4	32-bit unsigned integer
            UINT32 calcul = sampleRate_ * lengthOfFormatData_ * numberOfChannel_ / 8 ; // 44100
            fichier << (byte) ( calcul & 0xFF ) ;
            calcul = calcul >> 8 ;
            fichier << (byte) ( calcul & 0xFF ) ;
            calcul = calcul  >> 8 ;
            fichier << (byte) ( calcul & 0xFF ) ;
            calcul = calcul  >> 8 ;
            fichier << (byte) ( calcul & 0xFF ) ;

            // 33-34	4	(BitsPerSample * Channels) / 8.1 - 8 bit mono2 - 8 bit stereo/16 bit mono4 - 16 bit stereo
            // Bytes per Sample Frame (a.k.a block align)	2	16-bit unsigned integer
            UINT32 calcul2 =  lengthOfFormatData_ * numberOfChannel_ / 8 ;
            fichier << (byte) ( calcul2 & 0xFF ) ;
            calcul2 = calcul2 >> 8 ;
            fichier << (byte) ( calcul2 & 0xFF ) ;


            // 35-36	16	Bits per sample
            // Bits per sample	2	16-bit unsigned integer
            UINT32 bitsPerSample = lengthOfFormatData_ ;
            fichier << (byte) ( bitsPerSample & 0xFF );
            bitsPerSample = bitsPerSample >> 8 ;
            fichier << (byte) ( bitsPerSample & 0xFF );

            // 37-40	"data"	"data" chunk header. Marks the beginning of the data section.
            fichier << "data" ;

            // 41-44	File size (data)	Size of the data section.

            tailleFichier = (UINT32) maxX * (UINT32)maxY * ( lengthOfFormatData_ / 8 ) * numberOfChannel_ *   repeatRec ;  // mais attention, on doit l'écrire en LITTLE ENDIAN

            fichier << (byte) ( tailleFichier & 0xFF ) ;
            tailleFichier = tailleFichier >> 8 ;
            fichier << (byte)( tailleFichier & 0xFF ) ;
            tailleFichier = tailleFichier>> 8 ;
            fichier << (byte)( tailleFichier & 0xFF ) ;
            tailleFichier = tailleFichier>> 8 ;
            fichier << (byte)( tailleFichier & 0xFF  );

            cerr << endl << endl << "SAVING" << endl << endl ;

            for ( int i = 0 ; i < maxX  ; i = i + 2 )
            {
                for (int j = 0 ; j < maxY  ; j++ )
                {
                    // for ( int k = 0 ; k < repeatRec ; k++ )
                    {
                        UINT32 pixel = getpixel(gScreenSurface, i, j ) ;
                        if ( i < 10 )
                            cerr << dec << pixel << "\t" << hex << pixel << "\t" ;

                        UINT16 pixel16 = (UINT16) ( pixel   ) ;
                        if ( i < 10 )
                            cerr << dec << pixel16 << "\t" << hex << pixel16 << "\t" ;

                        UINT8 byte1 =   (UINT16)( pixel16  &  (UINT16)0xFFu ) ;
                        UINT16 forpr = byte1 ;
                        if ( i < 10 )
                            cerr  << dec << forpr  << "\t" ;

                        fichier << byte1 ;

                        pixel16  = pixel16  >> 8 ;
                        UINT8 byte2 =  (UINT16)( pixel16  & (UINT16) 0xFFu ) ;
                        forpr  = byte2 ;
                        if ( i < 10 )
                            cerr  << dec << forpr  << "\t" << endl ;

                        fichier <<  byte2  ;

                        // if ( numberOfChannel_ > 1 )
                        {
                            UINT32 pixel = getpixel(gScreenSurface, i+1, j ) ;

                            UINT16 pixel16 = (UINT16) ( pixel   ) ;

                            UINT8 byte1 =   (UINT16)( pixel16  &  (UINT16)0xFFu ) ;
                            UINT16 forpr = byte1 ;

                            fichier << byte1 ;

                            pixel16  = pixel16  >> 8 ;
                            UINT8 byte2 =  (UINT16)( pixel16  & (UINT16) 0xFFu ) ;
                            forpr  = byte2 ;

                            fichier <<  byte2  ;
                        }


                    }
                }
            }
        }

        fichier.close();
    }
    else
        cerr << "Impossible d'ouvrir le fichier !" << endl;

}


void loadWAV ( string name, SDL_Surface *surface )
{
    int n = name.length();
    char char_array[n+1];
    strcpy(char_array, name.c_str());

    ifstream fichier(char_array);  // ouverture en lecture

    if(fichier)
    {
        // on veut connaître la taille du fichier
        fichier.seekg(0, ios::end);
        long long taille;
        taille = fichier.tellg();
        cerr << "taille = " << taille << endl ;

        // ne pas oublier de retourner au point de départ
        fichier.seekg(0,ios::beg);

        long long position ;

        char small_ ;

        cerr << "lecture " << name << endl ;

        // lecture du header
        for (int i = 0; i < 44 ; i++ )
        {
            fichier.get(small_);
            cerr << i << "=" << (int) small_   << " [" << (char) small_ << "]" << endl;
        }

        for ( int i = 0 ; i < maxX ; i = i + 2 )
        {
            for (int j = 0 ; j < maxY ; j++ )
            {
                INT32 valeur1 = 0 ;
                INT32 valeur2 = 0 ;
                fichier.get(small_);

                valeur1 = (byte) small_ ;
                fichier.get(small_); // 2ème partie de la valeur 16 bits, little endian
                valeur2 = (byte) small_ ;

                valeur2 = valeur2 << 8 ;
                valeur2 = valeur2 + valeur1 ;


                cerr << hex << valeur2 << " - " ;

                putpixel(surface,i,j,valeur2 * (INT32) 0xFF );

                valeur1 = 0 ;
                valeur2 = 0 ;
                fichier.get(small_);
                valeur1 = (byte) small_ ;
                fichier.get(small_); // 2ème partie de la valeur 16 bits, little endian
                valeur2 = (byte) small_ ;
                valeur2 = valeur2 << 8 ;
                valeur2 = valeur2 + valeur1 ;


                cerr << hex << valeur2  ;

                putpixel(surface,i+1,j,valeur2 * (INT32) 0xFF );

                position =   fichier.tellg(); //On récupére la position
                cerr << " at " << position << endl ;

                int c = fichier.peek();  // peek character
                if ( c == EOF || position >= ( taille - 1  ))
                {
                    cerr << "finished reading at " << i << "-" << j << "=" << i*maxY + j << endl ;
                    i = maxX ;
                    j = maxY ;
                } // on arrête de lire
            }
        }


        fichier.close();
    }
    else
    {
        cerr << name << endl ;
        cerr << "Impossible d'ouvrir le fichier en lecture!" << endl;
    }

}

ownOutline( SDL_Surface *surface, int x1, int y1, int x2, int y2, Uint32 color )
{

    for ( int i = x1; i < x2; i++ )
    {
        putpixel(surface,i,y1,color);
        putpixel(surface,i,y2,color);
    }


    for ( int i = y1; i < y2; i++ )
    {
        putpixel(surface,x1,i,color);
        putpixel(surface,x2,i,color);
    }


}

void PlaySound(char *file)
{
    int index;
    SDL_AudioSpec wave;
    Uint8 *data;
    Uint32 dlen;
    SDL_AudioCVT cvt;

    /* Look for an empty (or finished) sound slot */
    for ( index=0; index<NUM_SOUNDS; ++index )
    {
        if ( sounds[index].dpos == sounds[index].dlen )
        {
            break;
        }
    }
    if ( index == NUM_SOUNDS )
        return;

    /* Load the sound file and convert it to 16-bit stereo at 22kHz */
    if ( SDL_LoadWAV(file, &wave, &data, &dlen) == NULL )
    {
        fprintf(stderr, "Couldn't load %s: %s\n", file, SDL_GetError());
        return;
    }
    SDL_BuildAudioCVT(&cvt, wave.format, wave.channels, wave.freq,
                      AUDIO_S16,   2,             22050);
    cvt.buf = ( Uint8*) malloc(dlen*cvt.len_mult);
    memcpy(cvt.buf, data, dlen);
    cvt.len = dlen;
    SDL_ConvertAudio(&cvt);
    SDL_FreeWAV(data);

    /* Put the sound data in the slot (it starts playing immediately) */
    if ( sounds[index].data )
    {
        free(sounds[index].data);
    }
    SDL_LockAudio();
    sounds[index].data = cvt.buf;
    sounds[index].dlen = cvt.len_cvt;
    sounds[index].dpos = 0;
    SDL_UnlockAudio();
}

static Uint8 *audio_pos; // global pointer to the audio buffer to be played
static Uint32 audio_len; // remaining length of the sample we have to play

  void my_audio_callback(void *userdata, Uint8 *stream, int len);

  // DEBUG vers PLAYZONE 3
  // https://ericscrivner.me/2017/10/getting-circular-sdl-audio/
  // https://github.com/etscrivner/sdl_audio_circular_buffer/commit/6ccb7a0fa4ba979e14d3f362ef03f83d750b7b90
  // https://atastypixel.com/a-simple-fast-circular-buffer-implementation-for-audio-processing/
  // https://soundprogramming.net/programming/creating-a-ring-buffer/
  // https://dobrian.github.io/cmp/topics/delay-based-effects/circularbuffer.html
  // https://learn.bela.io/tutorials/c-plus-plus-for-real-time-audio-programming/circular-buffers/
  // https://stackoverflow.com/questions/63456223/how-to-record-continuous-raw-audio-data-into-a-circular-buffer-with-c-on-windo
  // https://stackoverflow.com/questions/61505537/sdl-openaudiodevice-continuous-play-from-real-time-processed-source-buffer
  // https://davidgow.net/handmadepenguin/ch8.html
  // https://davidgow.net/handmadepenguin/ch9.html

void playZone2 ()
{


    const int high = 420 ;
    const      int lo = 10 ;

   Uint8 dataPixel[high-lo][high-lo] = {0} ;


// prototype for our audio callback
// see the implementation for more information

// variable declarations


    // local variables
    static Uint32 wav_length; // length of our sample
    static Uint8 *wav_buffer; // buffer containing our audio file
    static SDL_AudioSpec wav_spec; // the specs of our piece of music

    wav_spec.channels = 2 ;
    wav_spec.format = AUDIO_S8 ;
    wav_spec.freq = 44100 ;
    // remplir les autres specs ! !!!

    /* Load the WAV */
    // the specs, length and buffer of our wav are filled
    /*
    if( SDL_LoadWAV(MUS_PATH, &wav_spec, &wav_buffer, &wav_length) == NULL ){
      return 1;
    }
    */

    // set the callback function
    wav_spec.callback = my_audio_callback;
    wav_spec.userdata = NULL;

    // set our global static variables
    audio_pos = wav_buffer; // copy sound buffer
    audio_len = wav_length; // copy file length

    Uint32 pixel ;

    for (int i = lo; i < high ; i++ )
    {
        for (int j = lo  ; j < high  ; j++ )
        {
            pixel = getpixel(gScreenSurface,i,j);
            dataPixel[i-lo ][j-lo ] = (Uint8) ( pixel / 0xFFF )     ;
            // cout << dataPixel[i-100][j-100] << " " ;
        }
    }
    cout << "a";

    audio_pos = &dataPixel[0][0]  ;
    audio_len = ( high - lo ) * ( high - lo )   ;

    SDL_CloseAudio();

    /* Open the audio device */
    if ( SDL_OpenAudio(&wav_spec, NULL) < 0 )
    {
        fprintf(stderr, "Couldn't open audio: %s\n", SDL_GetError());
        exit(-1);
    }

    cout << "b";
    /* Start playing */
    SDL_PauseAudio(0);
    cout << "c";
    // shut everything down
    // SDL_CloseAudio();
    /// SDL_FreeWAV(wav_buffer);
}

// audio callback function
// here you have to copy the data of your audio buffer into the
// requesting audio buffer (stream)
// you should only copy as much as the requested length (len)
void my_audio_callback(void *userdata, Uint8 *stream, int len)
{

    if (audio_len ==0)
        return;
    cout << "preD";
    len = ( len > audio_len ? audio_len : len );
    //SDL_memcpy (stream, audio_pos, len); 					// simply copy from one buffer into the other
    SDL_MixAudio(stream, audio_pos, len, SDL_MIX_MAXVOLUME);// mix from one buffer into another
    cout << "d" ;
    audio_pos += len;
    audio_len -= len;
}


#include <queue>
#include <cmath>


const int AMPLITUDE = 28000;
const int SAMPLE_RATE = 44100;

void audio_callback(void *user_data, Uint32 *raw_buffer, int bytes)
{
    Sint32 *buffer = (Sint32*)raw_buffer;
    int length = bytes / 2; // 2 bytes per sample for AUDIO_S16SYS
    int &sample_nr(*(int*)user_data);

    for(int i = 0; i < length; i++, sample_nr++)
    {
        double time = (double)sample_nr / (double)SAMPLE_RATE;
        buffer[i] = (Sint32)(AMPLITUDE * sin(2.0f * M_PI * 441.0f * time)); // render 441 HZ sine wave
    }
}


void clearMasque()
{
    for ( int i = 0 ; i < SCREEN_WIDTH ; i ++)
    {
        for (int j = 0 ; j < SCREEN_HEIGHT ; j++ )
        {
            masque[i][j] = 0 ;
        }
    }
    return ;
}

// ces fonctions sont faites pour pouvoir plus tard les transformer en fonctions requérant 8x moins d'espace,
// où ce sont alors des bits qui seront activés, pas des bytes

void activeMasque(int x, int y )
{
    masque[x][y] = 1 ;
}

void annulateMasque(int x, int y )
{
    masque[x][y] = 0 ;
}

bool isMasqueActivated(int x, int y )
{
    if ( masque[x][y] == 1 )
    {
        return true ;
    }
    return false ;
}

void border ( int &number, int min, int max  )
{
    if ( number < min )
    {
        number = min ;
    }
    if ( number > max )
    {
        number = max ;
    }
}

int chosenR = 0 ;
int chosenG = 0 ;
int chosenB = 0 ;
int range = 30 ;

bool testPixel(int x, int y)
{
    // cout << endl << "testing pixel " << x << " " << y << endl ;

    Uint32 pixel = getpixel(gScreenSurface,x,y);

    Uint32 killR = (( pixel >>( 16 ) ) & 0xFF )  ;
    Uint32 killG = (( pixel >>( 8 ) )  & 0xFF )  ;
    Uint32 killB = (( pixel >>( 0 ) )  & 0xFF )  ;
    bool verif = true ;

    if ( abs( killR - chosenR ) > range  )
    {
        verif = false ;
    }
    if ( abs( killG - chosenG ) > range  )
    {
        verif = false ;
    }
    if ( abs( killB - chosenB ) > range  )
    {
        verif = false ;
    }

    return verif ;
}

void selectPixelAndVoisins(int x, int y, int level   )
{
    // if (   masque[x][y] == 1 ) { return ; }
    if ( level > 10000 )
    {
        return ;
    }

    int i = x - 1 ;
    border (i, 0, SCREEN_WIDTH-1);

    int k = x + 1 ;
    border (k, 0, SCREEN_WIDTH-1);

    int j = y - 1 ;
    border (j, 0, SCREEN_HEIGHT-1);

    int l = y + 1 ;
    border (l, 0, SCREEN_HEIGHT-1);

    for ( int m = k ; m >= i ; m-- )
    {
        for ( int n = j ; n <= l ; n++)
        {
            if (( (m == x) && (n == y) ) == false )
            {
                if ( masque[m][n] == 0   )     // non testé
                {
                    if ( testPixel(m,n) == true    )
                    {
                        masque[m][n] = level ;
                        selectPixelAndVoisins(m,n, level +1   );
                    }
                    else
                    {
                        masque[m][n] = -1 ; // signifie testé
                    }
                }
            }
        }
    }
}

// on devra ajouter ici une condition
void selectMasque(int x, int y)
{
    selectPixelAndVoisins(x,y, 0 );
}

void selectPixelAndVoisinsDifferential(int x, int y, int level   )
{
    // if (   masque[x][y] == 1 ) { return ; }
    if ( level > 10000 )
    {
        return ;
    }

    int i = x - 1 ;
    border (i, 0, SCREEN_WIDTH-1);

    int k = x + 1 ;
    border (k, 0, SCREEN_WIDTH-1);

    int j = y - 1 ;
    border (j, 0, SCREEN_HEIGHT-1);

    int l = y + 1 ;
    border (l, 0, SCREEN_HEIGHT-1);

          Uint32 pixel = getpixel(gScreenSurface,x,y);

    chosenR = (( pixel >>( 16 ) ) & 0xFF )  ;
    chosenG = (( pixel >>( 8 ) )  & 0xFF )  ;
    chosenB = (( pixel >>( 0 ) )  & 0xFF )  ;

    range = rand()%10 ;

    for ( int m = k ; m >= i ; m-- )
    {
        for ( int n = j ; n <= l ; n++)
        {
            if (( (m == x) && (n == y) ) == false )
            {
                if ( masque[m][n] == 0   )     // non testé
                {
                    if ( testPixel(m,n) == false    )
                    {
                        masque[m][n] = level ;
                        selectPixelAndVoisinsDifferential(m,n, level +1   );
                    }
                    else
                    {
                        masque[m][n] = -1 ; // signifie testé
                    }
                }
            }
        }
    }
}

void selectMasqueDifferential(int x, int y)
{
    selectPixelAndVoisinsDifferential(x,y, 0 );
}

void paintMasque(int U, int R, int G, int B )
{

    Uint32 color = (U << 24) + (R << 16) + (G << 8 ) + B ;

    Uint32 mult = rand();
    Uint32 modu = rand()%200 ;

    int choice = rand()% 8 ;
    for ( int m = 0 ; m < SCREEN_WIDTH ; m++ )
    {
        for ( int n = 0 ; n < SCREEN_HEIGHT ; n++)
        {
            if (  masque[m][n] > 0 )
            {
                 if (choice == 0)putpixel(gScreenSurface,m,n,masque[m][n]%500 * 100 );   // blue green recursion
             if (choice == 1)    putpixel(gScreenSurface,m,n,masque[m][n]%3  * 0xFFFF00 );   // yellow fish
               if (choice == 2)  putpixel(gScreenSurface,m,n,masque[m][n]%10  * 0xFFFF00 );   // savane
               if (choice == 3)  putpixel(gScreenSurface,m,n,masque[m][n]%10  * 0xFFFF00 + masque[m][n]  % 0xFF );   // yellow fish
               if (choice == 7)  putpixel(gScreenSurface,m,n,masque[m][n]%modu  * mult   );   // yellow fish
               if (choice == 4)  putpixel(gScreenSurface,m,n,masque[m][n]%100 );      // deep blue wave
            if (choice == 5)putpixel(gScreenSurface,m,n, color  );
                 if (choice == 6)  putpixel(gScreenSurface,m,n,masque[m][n]*1000 );
                // if (choice == 7)  putpixel(gScreenSurface,m,n,) );

            }
        }
    }
}

void invertMasque(  )
{
    for ( int m = 0 ; m < SCREEN_WIDTH ; m++ )
    {
        for ( int n = 0 ; n < SCREEN_HEIGHT ; n++)
        {
            if (  masque[m][n] == 0 )
            {
 masque[m][n] = 1 ;
            }
            else
            {
                masque[m][n] = 0 ;
            }
        }
    }
}

void cleavageMasque(int x, int y, int level, int nbBranch = 0 )
{
    if ( level > 100 )
    {
        return ;
    }

      if ( ( level % 10 == 0 ) && ( nbBranch < 100 )  )     // devrait recréer un deuxième embranchement tous les 10 levels
  {
      cleavageMasque(x,y,level+1,nbBranch+1);
      // return ;
  }

    if ( x < 2 ) { return ; }
    if ( x > (SCREEN_WIDTH - 2) ) { return ; }
    if ( y < 2 ) { return ; }
    if ( y > (SCREEN_HEIGHT - 2) ) { return ; }

    // on va faire un premier tour pour trouver les pixels qui sont candidats
vector<int> vect ;


  if ( testPixel(x-1,y) == true && masque[x-1][y-1] == 0 && masque[x-1][y+1] == 0 )
  {
      vect.push_back(1);
  }

    if ( testPixel(x+1,y) == true && masque[x+1][y-1] == 0 && masque[x+1][y+1] == 0 )
  {
      vect.push_back(2);
  }


  if ( testPixel(x,y-1) == true && masque[x-1][y-1] == 0 && masque[x+1][y-1] == 0 )
  {
      vect.push_back(3);
      vect.push_back(3);
      vect.push_back(3);
  }

    if ( testPixel(x,y+1) == true && masque[x-1][y+1] == 0 && masque[x+1][y+1] == 0 )
  {
      vect.push_back(4);
      vect.push_back(4);
  }

  int tailleVect = vect.size();

  if ( tailleVect == 0 ) { return ; }

  int choix = rand()% tailleVect ; // on choisit parmi les cibles une direction
  int direction = vect[choix];

  if ( direction == 1 )
  {
      masque[x-1][y] = level ;
      cleavageMasque(x-1,y,level+1,nbBranch) ;
  }

      if ( direction == 2 )
  {
      masque[x+1][y] = level ;
      cleavageMasque(x+1,y,level+1,nbBranch) ;
  }

    if ( direction == 3 )
  {
      masque[x][y-1] = level ;
      cleavageMasque(x,y-1,level+1,nbBranch) ;
  }

    if ( direction == 4 )
  {
      masque[x][y+1] = level ;
      cleavageMasque(x,y+1,level+1,nbBranch) ;
  }



  return ;
}

// version moins récursive
void cleavageMasque2(int x, int y, int level, int nbBranch = 0 )
{
    if ( level > 1000 )
    {
       return ;
    }

  bool keepOn = true ;

      // on va faire un premier tour pour trouver les pixels qui sont candidats
vector<int> vect ;

  while ( keepOn == true )
  {

    if ( x < 2 ) { return ; }
    if ( x > (SCREEN_WIDTH - 2) ) { return ; }
    if ( y < 2 ) { return ; }
    if ( y > (SCREEN_HEIGHT - 2) ) { return ; }

        if ( ( level % 30 == 0 ) && ( nbBranch < 100 )  )     // devrait recréer un deuxième embranchement tous les 10 levels
  {
// cleavageMasque2(x,y,level+1,nbBranch+1);
      // return ;
  }

  if ( level > 1000 ) { keepOn = false ; }

vect.clear();

  if ( testPixel(x-1,y) == true && masque[x-1][y-1] == 0 && masque[x-1][y+1] == 0 )
  {
      vect.push_back(1);
  }

    if ( testPixel(x+1,y) == true && masque[x+1][y-1] == 0 && masque[x+1][y+1] == 0 )
  {
      vect.push_back(2);
      vect.push_back(2);
  }

  if ( testPixel(x,y-1) == true && masque[x-1][y-1] == 0 && masque[x+1][y-1] == 0 )
  {
      vect.push_back(3);
      vect.push_back(3);
      vect.push_back(3);
  }

    if ( testPixel(x,y+1) == true && masque[x-1][y+1] == 0 && masque[x+1][y+1] == 0 )
  {
      vect.push_back(4);
//      vect.push_back(4);
  }

  int tailleVect = vect.size();

  if ( tailleVect == 0 ) { keepOn = false ; return ; }

  int choix = rand()% tailleVect ; // on choisit parmi les cibles une direction
  int direction = vect[choix];

  if ( direction == 1 )
  {
      masque[x-1][y] = level ;
      x = x - 1 ;
      level = level + 1 ;
      // cleavageMasque(x-1,y,level+1,nbBranch) ;
  }

      if ( direction == 2 )
  {
      masque[x+1][y] = level ;
      x = x + 1 ;
      level = level + 1 ;
//      cleavageMasque(x+1,y,level+1,nbBranch) ;
  }

    if ( direction == 3 )
  {
      masque[x][y-1] = level ;
      y = y - 1 ;
      level = level + 1 ;
//      cleavageMasque(x,y-1,level+1,nbBranch) ;
  }

    if ( direction == 4 )
  {
      masque[x][y+1] = level ;
      y = y +1 ;
      level = level + 1 ;
//      cleavageMasque(x,y+1,level+1,nbBranch) ;
  }

  }

  return ;
}


void paintMasqueRegular(int U, int R, int G, int B )
{

    Uint32 color = (U << 24) + (R << 16) + (G << 8 ) + B ;

    for ( int m = 0 ; m < SCREEN_WIDTH ; m++ )
    {
        for ( int n = 0 ; n < SCREEN_HEIGHT ; n++)
        {
            if (  masque[m][n] > 0 )
            {
                 putpixel(gScreenSurface,m,n,color);

            }
        }
    }
}

int orientation(int a )
{
    if ( a < 0 ) { return -1 ; }
    else
    {
         return 1 ;
    }
}

Uint32 intermediateColor( Uint32 color1 , Uint32 color2, float percentage )
/** \brief donne la valeur intermédiaire à l'endroit % (0-100) entre 2 couleurs
 *
 * \param couleur initiale
 * \param couleur finale
 * \param pourcentage de chemin, entre 0 et 100
 * \return
 *
 */
{
  //  cout << "color1 = " << color1 << " color2 = " << color2 << endl ;
    Uint32 Red1 = (color1 >> 16 ) & 0xFF ;
    Uint32 Green1 = (color1 >> 8 ) & 0xFF ;
    Uint32 Blue1 = (color1 >> 0 ) & 0xFF ;

    Uint32 Red2 = (color2 >> 16 ) & 0xFF ;
    Uint32 Green2 = (color2 >> 8 ) &0xFF ;
    Uint32 Blue2 = (color2 >> 0 ) & 0xFF ;

    int differenceRed = (int) Red2 - (int)Red1 ;
    int differenceGreen = (int)Green2 - (int)Green1 ;
    int differenceBlue = (int)Blue2 -(int) Blue1 ;

   // cout << "passage de " << (int) Red1 << " a " << (int)Red2 << " = " << differenceRed << endl ;
  // cout << "passage de " << (int)Green1 << " a " << (int)Green2 << " = " << differenceGreen << endl ;
  // cout << "passage de " << (int)Blue1 << " a " << (int)Blue2 << " = " << differenceBlue << endl ;

    int step0 = 0 ;
    int  step1 = abs(differenceRed) + step0 ;
   int  step2 = abs(differenceGreen) + step1  ;
   int  step3 = abs(differenceBlue) + step2 ;

//   cout << endl ;
 //  cout <<   step0 << " " << step1 << " " << step2 << " " << step3 << endl ;

    // transformation du % en valeur int, 100% valant step3

    int wantedStep = 0 ;
    wantedStep = (int) ( (float) ( ( (float) percentage * (float) step3 ) / ( float ) 100 ) ) ;

  // cout << "wanted percentage " << percentage << " = " << wantedStep << endl ;

     int finalRed, finalGreen, finalBlue ;

 // TRAITEMENT DU ROUGE

 finalRed = Red1 ; // valable si % vaut zéro

    if ( (wantedStep > step0) && (wantedStep < step1) )
    {
        if ( differenceRed != 0 )
        {
        finalRed = (int) Red1 + (  wantedStep ) * orientation(differenceRed);
        }
        else
        {
            finalRed= Red1 ;
        }
    }

    if ( wantedStep >= step1 )
    {
        finalRed = Red2 ;
    }

 // TRAITEMNT DU VERT

 finalGreen = Green1 ;

 if ( (wantedStep > step1) && (wantedStep < step2) )
 {
     if ( differenceGreen != 0 )
     {
              finalGreen = (int) Green1 +  ( wantedStep - step1 ) * orientation(differenceGreen) ;
     }
     else
     {
         finalGreen = Green2 ;
     }
 }

 if ( wantedStep >=step2 )
 {
     finalGreen = Green2 ;
 }

 // TRAITEMENT DU BLEU

 finalBlue = Blue1 ;

 if ( (wantedStep > step2) && (wantedStep < step3) )
 {
     if ( differenceBlue != 0 )
     {
     finalBlue = (int) Blue1 +  ( wantedStep - step2) * orientation(differenceBlue) ;
     }
     else
     {
         finalBlue = Blue2 ;
     }
 }

 if ( wantedStep >= step3 )
 {
     finalBlue = Blue2 ;
 }

 Uint32 finalResult = (Uint32)(  finalRed << 16) + ( finalGreen << 8 ) + ( finalBlue ) ;

  // cout << hex << color1 << " " << color2 << " final Result " << hex << finalResult << dec << endl ;

   return finalResult ;
}


// annulateMasque va effacer le contenu récurrent du masque

bool isZoneHomogeneUnderDeviation ( int x1, int y1, int x2, int y2, int variationMax )
{


    Uint32 pixel ;
                        Uint32 moyenne   = {0}  ;
                        Uint32 moyenneR  = {0} ;
                        Uint32 moyenneG = {0};
                        Uint32 moyenneB  = {0} ;



    Uint32 taille = ( x2 - x1 + 1 ) * ( y2 - y1 + 1 ) ;

    for (int i = x1 ; i <= x2 ; i++ )
    {
        for (int j = y1 ; j <= y2 ; j++ )
        {
                                pixel = getpixel(gScreenSurface,i,j);
                                moyenneR += (( pixel >>16 ) & 0xFF ) ;
                                moyenneG += (( pixel >>8 ) & 0xFF ) ;
                                moyenneB += ((pixel >>0 ) & 0xFF ) ;
        }
    }


          moyenneR /= taille  ;
                            moyenneG /= taille  ;
                            moyenneB /= taille  ;


       for (int i = x1 ; i <= x2 ; i++ )
    {
        for (int j = y1 ; j <= y2 ; j++ )
        {
                                pixel = getpixel(gScreenSurface,i,j);
                                if ( abs ((( pixel >>16 ) & 0xFF ) - moyenneR )  > variationMax ) { return false ; }  ;
                                if ( abs ((( pixel >>8 ) & 0xFF ) - moyenneG )  > variationMax ) { return false ; }  ;
                                if ( abs ((( pixel >>0 ) & 0xFF ) - moyenneB )  > variationMax ) { return false ; }  ;

        }
    }
;

return true ;
}

void findHomogenousUnder ( int variation )
{
    clearMasque();

    for ( int i = 0 ; i < SCREEN_WIDTH - 2  ; i++ )
    {
        for ( int j = 0 ; j < SCREEN_HEIGHT - 2 ; j++ )
        {
           if ( isZoneHomogeneUnderDeviation(i,j,i+2,j+2,5))
           {
               masque[i+1][j+1] = 1 ;
           }
        }
    }
}




/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// MAIN
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

int main( int argc, char* args[] )
{

//Start up SDL and create window
    if( !init() )
    {
        printf( "Failed to initialize!\n" );
    }
    else
    {
        //Load media
        if( !loadMedia() )
        {
            printf( "Failed to load media!\n" );
        }
        else
        {
        }
    }

  //  intermediateColor(0xFF1010, 0x00F2D2, 20);
  //  SDL_Delay(10000);

    float  syncCompensationFactor = 0.001;// decrease to reduce risk of collision, increase to lower latency
    Sint32 mainAudioLead;
    Uint32 i;

    voice testVoiceA;
    voice testVoiceB;
    voice testVoiceC;
    testVoiceA.volume = 1;
    testVoiceB.volume = 1;
    testVoiceC.volume = 1;
    testVoiceA.pan = 0.5;
    testVoiceB.pan = 0;
    testVoiceC.pan = 1;
    testVoiceA.phase = 0;
    testVoiceB.phase = 0;
    testVoiceC.phase = 0;
    testVoiceA.frequency = getFrequency(45);// A3
    testVoiceB.frequency = getFrequency(46);// C#4
    testVoiceC.frequency = getFrequency(50);// E4
    Uint16 C0waveformLength = getWaveformLength(0);
    C0waveformLength = 16000 ;
    // MODIF

    testVoiceA.waveformLength = C0waveformLength;
    testVoiceB.waveformLength = C0waveformLength;
    testVoiceC.waveformLength = C0waveformLength;
    float sineWave[C0waveformLength];
    buildSineWave(sineWave, C0waveformLength);

    testVoiceA.waveform = sineWave;
    testVoiceB.waveform = sineWave;
    testVoiceC.waveform = sineWave;


    SDL_PauseAudioDevice(AudioDevice, 0);// unpause audio.


    logVoice(&testVoiceA);
    logWavedata(testVoiceA.waveform, testVoiceA.waveformLength, 10);

    SDL_Delay(4000);

    srand (time(NULL));

    ajouteItem(".JPG");
    ajouteItem(".gif");
    ajouteItem(".png");
    ajouteItem(".bmp");

    resetListCounters() ; // on met le compteur de liste à zéro

    for ( int i = 0 ; i < sizeColorPick ; i++ )
    {
        for (int j = 0 ; j < sizeColorPick ; j++ )
        {
            for ( int k = 0 ; k < sizeColorPick ; k++)
            {
                colorPick[i][j][k] = 0 ;
            }
        }
    }

    DWORD dwRet;

    dwRet = GetCurrentDirectory(BUFSIZE, Buffer);

    _tprintf(TEXT("folder de depart :\n"), "");
    _tprintf(TEXT("%s\n"), Buffer );
    cout << endl ;

    strcpy(pathToAnalyze,Buffer);
    strcpy(initialPath,Buffer);
    strcpy(veryInitialPath,Buffer);

    totalFilesNumber = 0 ;
    resetListCounters() ;
    explicitTotalList(pathToAnalyze,   0 ) ;


    cout << "total=" << totalFilesNumber << endl ;
    cout << endl ;


    cout << endl << "decompte de la liste de recherche" << endl ;

    for ( int i = 0 ; i < maListe.size() ; i++ )
    {
        cout << maListe[i].nom << " = " << maListe[i].nombre << endl ;
    }

    SDL_Event event; // Cette variable servira plus tard à gérer les événements
    bool continuer = true ;

    positionFond.x = 0;
    positionFond.y = 0;
    positionimpact.x = 0;
    positionimpact.y = 0;

    //Initialize SDL
    if( SDL_Init( SDL_INIT_VIDEO | SDL_INIT_AUDIO ) < 0 )
    {
        printf( "SDL could not initialize! SDL Error: %s\n", SDL_GetError() );

    }


    int imgFlags = IMG_INIT_PNG;
    if( !( IMG_Init( imgFlags ) & imgFlags ) )
    {
        printf( "SDL_image could not initialize! SDL_image Error: %s\n", IMG_GetError() );
        // success = false;
    }
    else
    {
        //Get window surface
        gScreenSurface = SDL_GetWindowSurface( gWindow );
    }


    //Initialize SDL_mixer
    if( Mix_OpenAudio( 44100, MIX_DEFAULT_FORMAT, 2, 2048 ) < 0 )
    {
        printf( "SDL_mixer could not initialize! SDL_mixer Error: %s\n", Mix_GetError() );
    }

    // ecran = SDL_SetVideoMode(maxX, maxY, 32, SDL_HWSURFACE);
    // impactCopy = SDL_SetVideoMode(maxX, maxY, 32, SDL_HWSURFACE);

    //  SDL_WM_SetCaption("uQitll-Ty5", NULL);


    TTF_Font *police = NULL;
    SDL_Color couleurNoire = {100, 100, 100};

    TTF_Init();

    /* Chargement de la police */
    police = TTF_OpenFont("arial.ttf", 80);
    // police = TTF_OpenFont("din1451alt.ttf", 80);
    /* Écriture du texte dans la SDL_Surface texte en mode Blended (optimal) */

    string display = "uQitll-ty6=" +  to_string(calculTotalFoundListFiles()) ;
    stringToConvert(display);
    couleurNoire = {220, 220, 220};
    texte = TTF_RenderText_Blended(police, display.c_str(), couleurNoire);

    positionimpact.x = rand()%120 ;;
    positionimpact.y = rand()%80 ;;

    SDL_BlitSurface(texte, NULL, gScreenSurface, &positionimpact); /* Blit du texte */
    SDL_UpdateWindowSurface( gWindow );

    //The window renderer
    SDL_Renderer* gRenderer = NULL;
    if( !SDL_SetHint( SDL_HINT_RENDER_SCALE_QUALITY, "1" ) )
    {
        printf( "Warning: Linear texture filtering not enabled!" );
    }

//Create renderer for window
    gRenderer = SDL_CreateRenderer( gWindow, -1, SDL_RENDERER_ACCELERATED );
    if( gRenderer == NULL )
    {
        printf( "Renderer could not be created! SDL Error: %s\n", SDL_GetError() );
        //	success = false;
    }
    SDL_RenderClear( gRenderer );



    partialFilesNumber = 0 ;
    totalFilesNumber = 0 ;

    giveNameOfSearchedFileNumber(pathToAnalyze,   0, 0);

    stringToConvert(fullNameSearched);

    long rememberNumber = calculTotalFoundListFiles() ;
    rememberNumber-- ;

    imageDeFond = IMG_Load( convert );
    if( imageDeFond == NULL )
    {
        printf( "Unable to load image %s! SDL_image Error: %s\n", convert, IMG_GetError() );
    }

    impactImage = IMG_Load( convert );

    positionFond.x = 30;
    positionFond.y = 90;
    positionimpact.x = 0;
    positionimpact.y = 0;

    SDL_BlitSurface(imageDeFond, NULL, gScreenSurface, &positionFond);

    //Update the surface
    SDL_UpdateWindowSurface( gWindow );

    SDL_Delay(2000);

    int valeurBaseTransparence = 0 ;
    int variationTransparence = 5 ;

    SDL_Rect first ;
    first.w = 100;
    first.h = 100;

    SDL_Event e;
    continuer = true ;
    int transparence = 0 ;

    //  TTF_Font *police = NULL;
    //    SDL_Color couleurNoire = {100, 100, 100};

    // LOAD MUSIC

    //Load music
    gMusic = Mix_LoadMUS( "21_sound_effects_and_music/beat.wav" );
    if( gMusic == NULL )
    {
        printf( "Failed to load beat music! SDL_mixer Error: %s\n", Mix_GetError() );

    }

    //Load sound effects
    gScratch = Mix_LoadWAV( "21_sound_effects_and_music/scratch.wav" );
    if( gScratch == NULL )
    {
        printf( "Failed to load scratch sound effect! SDL_mixer Error: %s\n", Mix_GetError() );

    }

    gHigh = Mix_LoadWAV( "21_sound_effects_and_music/high.wav" );
    if( gHigh == NULL )
    {
        printf( "Failed to load high sound effect! SDL_mixer Error: %s\n", Mix_GetError() );

    }

    gMedium = Mix_LoadWAV( "21_sound_effects_and_music/medium.wav" );
    if( gMedium == NULL )
    {
        printf( "Failed to load medium sound effect! SDL_mixer Error: %s\n", Mix_GetError() );

    }

    gLow = Mix_LoadWAV( "21_sound_effects_and_music/low.wav" );
    if( gLow == NULL )
    {
        printf( "Failed to load low sound effect! SDL_mixer Error: %s\n", Mix_GetError() );

    }

    cout << "YES" ;
    SDL_Delay(2000);

///////////////////////////////////////////:
// MAIN LOOP
///////////////////////////////////////////:

    while(continuer == true )
    {
        cout << "*";


        // GESTION DU X Y



        int transparence = valeurBaseTransparence + rand() % variationTransparence ;


        if ( transparence <= 0 )
        {
            transparence = 1 ;
        }
        if ( transparence >= 255 )
        {
            transparence = 255 ;
        }

        //   cout << transparence ;

        //   SDL_SetAlpha(impact, SDL_SRCALPHA, transparence );
// SDL_SetTextureAlphaMod( NULL, transparence );

        int initialX =   rand()% pragmaticalMaxX  ;
        int initialY =   rand()% pragmaticalMaxY ;

        initialX = initialX - ( initialX  % fixSpacingx ) ;
        initialY = initialY - ( initialY  % fixSpacingy ) ;

        int repeatX = 1 ;
        int repeatY = 1 ;

        if ( modeChess == true )
        {
            repeatX = rand()%16 ;
            repeatY = rand()%16 ;
        }

        // variationX = 200 ;
        // variationY = 200 ;

        // cout << "a";
        int maxImpactx = impactImage ->w ;
        int maxImpacty = impactImage ->h ;

        // cout << "b";
        int tempW = basicW + rand()%variationX ;
        int tempH = basicH + rand()%variationY ;

        //cout << "c";
        int val1 = impactImage->w - tempW ;
        if  ( val1 <=0 )
        {
            val1 = 1 ;
        }
        int val2 = impactImage->h - tempH;
        if  ( val2 <=0 )
        {
            val2 = 1 ;
        }


        int tempX = rand()%(val1) ;
        int tempY = rand()%(val2) ;

        //cout << "d";

        first.w = tempW ;
        first.h = tempH ;
        first.x = tempX ;
        first.y = tempY ;

        positionimpact.x = rand()% pragmaticalMaxX ;
        positionimpact.y =  rand()% pragmaticalMaxY  ; ;

        if ( rand() % 100 == 0 )
        {
            SDL_FreeSurface(impactImage);
            SDL_FreeSurface(impactCopy);

            do
            {
                cout << "changing";
                changeImage = nextImage + rand() % nextImageVariation + 1   ;

                strcpy(pathToAnalyze,Buffer);

                partialFilesNumber = 0 ;
                totalFilesNumber = 0 ;
                giveNameOfSearchedFileNumber(pathToAnalyze,   0, rand() % (int) ( rememberNumber %  1000 ) );

                // stringToConvert(fullNameSearched);

                cout << fullNameSearched << endl ;

                //  impactImage = IMG_Load(convert);
                impactCopy= IMG_Load(fullNameSearched.c_str());
                impactImage = SDL_ConvertSurface( impactCopy, gScreenSurface->format, 0 );

                // impactCopy = IMG_Load(fullNameSearched.c_str());
                //  cout << "LOADED" ;

                if ( impactImage == NULL )
                {
                    cout << "NULL" << endl ;
                    // DOIT ALORS CHARGER AUTRE CHOSE !
                }

                // SDL_Delay(100);
            }
            while ( impactImage == NULL ) ;
            // SDL_Delay(100);

            SDL_Rect initi ;
            initi.x = 0 ;
            initi.y = 0 ;
            // SDL_BlitSurface(impact,NULL,impactCopy,&initi);
            // impactCopy = SDL_ConvertSurface( impactImage, ecran->format, 0 );
            //   cout << "CONVERTED" ;
        }

        if ( rand() % attente == 0 )
        {
            for (int i = 0 ; i < repeatX ; i++ )
            {
                first.x = ( tempX + i * 10 ) % maxImpactx  ;
                positionimpact.x = ( initialX + i * tempW ) % maxX  ;

                for ( int j = 0 ; j < repeatY ; j++ )
                {
                    first.y = ( tempY + j * 10 ) % maxImpacty ;
                    positionimpact.y = ( initialY + j * tempH ) % maxY ;

                    if ( (i % 2) == (j % 2) )
                    {
                        if ( rand()%8 <= 4 )
                        {
                            // SDL_BlitSurface(impact, &first, ecran, &positionimpact);
                            //
                            ownBlit(impactImage,first.x,first.y,first.w,first.h, gScreenSurface, minimumW + positionimpact.x, minimumH + positionimpact.y,
                                    transparence, 0 );
                            // DEBUG était avant impactCopy

                            // SDL_BlitSurface(impactImage, &first, gScreenSurface, &positionimpact);

                            SDL_UpdateWindowSurface( gWindow );
                        }
                    }
                }
            }
        }

        while( SDL_PollEvent( &event ) != 0 )
        {
            switch(event.type)
            {

            case SDL_QUIT:
                continuer = 0;
                break;

            case SDL_KEYDOWN:
            {
                switch (event.key.keysym.sym)
                {
                case SDLK_ESCAPE: /* Appui sur la touche Echap, on arrête le programme */
                    continuer = 0;
                    break;

                case SDLK_0: // Appui sur la touche  0
                {
                    page = '0' ;
              //      Mix_PlayChannel( -1, gHigh, 0 );

                }
                break;

                case SDLK_1: // Appui sur la touche  1
                {
                    page = '1' ;
                //    Mix_PlayChannel( -1, gMedium, 0 );
                }
                break;

                case SDLK_2: // Appui sur la touche 2
                {
                    page = '2' ;
               //     Mix_PlayChannel( -1, gLow, 0 );
                }
                break;

                case SDLK_3: // Appui sur la touche 3
                {
                    page = '3' ;
               //     Mix_PlayChannel( -1, gScratch, 0 );
                }
                break;

                case SDLK_4: // Appui sur la touche 4
                {
                    page = '4' ;
//If there is no music playing

/*
                    if( Mix_PlayingMusic() == 0 )
                    {
                        //Play the music
                        Mix_PlayMusic( gMusic, -1 );
                    }
                    //If music is being played
                    else
                    {
                        //If the music is paused
                        if( Mix_PausedMusic() == 1 )
                        {
                            //Resume the music
                            Mix_ResumeMusic();
                        }
                        //If the music is playing
                        else
                        {
                            //Pause the music
                            Mix_PauseMusic();
                        }
                    }
*/
                }
                break;

                case SDLK_5: // Appui sur la touche 5
                {
                    page = '5' ;
                  //  Mix_HaltMusic();
                }
                break;

                case SDLK_6: // Appui sur la touche 6
                {
                    page = '6' ;
                    cout << endl << endl << endl << "page 6" ;

                    int nbZones = zonePoints.size() / 2 ;

                    cout << "i sense " << nbZones << " zones " ;

                    if (nbZones >= 1)
                    {
                        for ( int i = 0 ; i < nbZones ; i++ )
                        {
                            // prévoir un switch des points si ils sont mal rangés !
                            // TODO
                            cout << "-------"<< endl ;
                            cout << zonePoints[i*2].x << "-" << zonePoints[i*2].y << " " << zonePoints[i*2+1].x << "-" << zonePoints[i*2+1].y << endl ;
                            ownOutline(gScreenSurface, zonePoints[i*2].x, zonePoints[i*2].y, zonePoints[i*2+1].x, zonePoints[i*2+1].y,
                                       0xFF00FF
                                      );
                        }
                    }
                    SDL_UpdateWindowSurface( gWindow );
                    SDL_Delay(1000);
                }
                break;

                case SDLK_7: // Appui sur la touche 7
                {
                    page = '7' ;
                    playZone2() ;
                }
                break;

                case SDLK_8: // Appui sur la touche 8
                {
                    page = '8' ;


                    //                 C0waveformLength = rand()%1000 + 1000 ;
                    buildPixelWave(sineWave, C0waveformLength);

                    testVoiceA.waveform = sineWave;
                  //  testVoiceB.waveform = sineWave;
                 //   testVoiceC.waveform = sineWave;

                    for (i=0; i<samplesPerFrame; i++)
                        audioBuffer[audioMainLeftOff+i] = 0;

                    //printf("audioMainLeftOff___________%5d\n", audioMainLeftOff);

                    speak(&testVoiceA);
                  //  speak(&testVoiceB);
                  //  speak(&testVoiceC);

                    testVoiceA.frequency = getFrequency(rand()%20+20);// C#4
                  //  testVoiceB.frequency = getFrequency(rand()%20+20);// C#4
                  //  testVoiceC.frequency = getFrequency(rand()%20+20);// C#4

                    if (audioMainAccumulator > 1)
                    {
                        for (i=0; i<samplesPerFrame; i++)
                        {
                            audioBuffer[audioMainLeftOff+i] /= audioMainAccumulator;
                        }
                    }
                    audioMainAccumulator = 0;

                    audioMainLeftOff += samplesPerFrame;
                    if (audioMainLeftOff == audioBufferLength)
                        audioMainLeftOff = 0;

                    mainAudioLead = audioMainLeftOff - SDL_AtomicGet(&audioCallbackLeftOff);
                    if (mainAudioLead < 0)
                        mainAudioLead += audioBufferLength;
                    //printf("mainAudioLead:%5d\n", mainAudioLead);
                    if (mainAudioLead < floatStreamLength)
                        printf("An audio collision may have occured!\n");
                    SDL_Delay( mainAudioLead*syncCompensationFactor );


                }
                break;

                case SDLK_9: // Appui sur la touche 9
                {
                    page = '9' ;

                }
                break;


                case SDLK_a: // Appui sur la touche q (place a), on modifie le % de variation de l'image en pixels
                {
                    mode = 'a' ;
                    if ( page == '0')
                    {
                        mode = 'a' ;
                    }

                    if ( page == '1')
                    {
                        fillPixel = rand()%16 + 1 ;
                        expand = rand()% 16 + 1 ;
                        string display ;
                        display                             = to_string(fillPixel)                              + "/"                              + to_string(expand)  ;

                        //  stringToConvert(display);
                        couleurNoire = {220, 220, 220};
                        texte = TTF_RenderText_Blended(police, display.c_str(), couleurNoire);
                        positionimpact.x = 40 ;;
                        positionimpact.y = 20 ;;
                        SDL_BlitSurface(texte, NULL, gScreenSurface, &positionimpact); /* Blit du texte */
                        SDL_UpdateWindowSurface( gWindow );
                        SDL_Delay(100);
                    }

                    if ( page == '5')
                    {
                        mode = 'a';
                    }

                    if ( page == '6')
                    {
                        mode = 'a';
                    }




                }
                break;

                case SDLK_b: // Appui sur la touche b, on crée une symétrie
                {
                    mode = 'b' ;
                    if ( page == '0')
                    {
                        symetries = !symetries ;
                        SDL_Delay(1000);
                    }

                    if ( page == '1')
                    {
                        modeRandomChanger = !modeRandomChanger ;

                        changeAll = 2000 ;
                        countdownChangeAll = 2;

                        string display = "auto "   ;
                        if (modeRandomChanger == true )
                        {
                            display += " ON" ;
                        }
                        else
                        {
                            display  += " OFF" ;
                        }

                        //  stringToConvert(display);
                        couleurNoire = {220, 220, 220};
                        texte = TTF_RenderText_Blended(police, display.c_str(), couleurNoire);
                        positionimpact.x = 40 ;;
                        positionimpact.y = 20 ;;
                        SDL_BlitSurface(texte, NULL, gScreenSurface, &positionimpact); /* Blit du texte */
                        SDL_UpdateWindowSurface( gWindow );

                        SDL_Delay(1000);
                    }
                }
                break;

                case SDLK_c: // Appui sur la touche c, on change d'image
                {

                    mode = 'c' ;
                    if ( page == '0' )
                    {


                        changeImage = 0 ;
                    }

                    if ( page == '1' )
                    {

                        for ( int i = 0 ; i < sizeColorPick ; i++ )
                        {
                            for (int j = 0 ; j < sizeColorPick ; j++ )
                            {
                                for ( int k = 0 ; k < sizeColorPick ; k++)
                                {
                                    colorPick[i][j][k] = rand()%2 ;
                                }
                            }
                        }

                    }

                    if ( page == '4' )
                    {
                        loadWAV("notify.wav", gScreenSurface);
                        SDL_Delay(100);

                    }
                }

                break;

                case SDLK_d: // Appui sur la touche d, on change les valeurs de maxX et maxY pragmatiques
                {
                    mode = 'd' ;
                    if ( page == '0')
                    {
                        pragmaticalMaxX = maxX ;
                        pragmaticalMaxY = maxY ;
                        mode = 'd' ;
                    }

                    if ( page == '1' )
                    {

                        for ( int i = 0 ; i < sizeColorPick ; i++ )
                        {
                            for (int j = 0 ; j < sizeColorPick ; j++ )
                            {
                                for ( int k = 0 ; k < sizeColorPick ; k++)
                                {
                                    colorPick[i][j][k] = 0 ;
                                }
                            }
                        }

                    }

                    if ( page == '2')
                    {
                        long cumul = rand() % 60000 ;
                        long keep = rand() % 60000 ;


                        long compteurCumul = 0 ;
                        long compteurKeep = 0 ;
                        for ( int i = 0 ; i < maxX ; i++ )
                        {
                            for ( int j = 0 ; j < maxY ; j++ )
                            {
                                if ( compteurCumul < cumul )
                                {
                                    putpixel(gScreenSurface,i,j,0) ;
                                    compteurCumul++ ;
                                }
                                else
                                {
                                    compteurKeep++ ;
                                }

                                if ( compteurKeep > keep )
                                {
                                    compteurCumul = 0 ;
                                    compteurKeep = 0 ;
                                }
                            }
                        }
                            SDL_UpdateWindowSurface( gWindow );
                        SDL_Delay(100);
                    }

                    if ( page == '5')
                    {
                        mode = 'd' ;
                    }


                }
                break;

                case SDLK_e: // Appui sur la touche e, on change les valeurs de duplication de symétries
                {
                    mode = 'e' ;
                    if ( page == '0')
                    {


                        freqSymetries = 100 ;
                        freqDuplicates = 500 ;

                        mode = 'e' ;
                    }

                    // EXTENSION DE LA PALETTE D'EXCLUSION
                    if ( page == '1')
                    {
                        char replicateColorPick [sizeColorPick][sizeColorPick][sizeColorPick] ;

                        // initialisation

                        for ( int i = 0 ; i < sizeColorPick ; i++ )
                        {
                            for (int j = 0 ; j < sizeColorPick ; j++ )
                            {
                                for ( int k = 0 ; k < sizeColorPick ; k++)
                                {
                                    replicateColorPick[i][j][k] = 0 ;
                                }
                            }
                        }

                        // initialisation

                        for ( int i = 0 ; i < sizeColorPick ; i++ )
                        {
                            for (int j = 0 ; j < sizeColorPick ; j++ )
                            {
                                for ( int k = 0 ; k < sizeColorPick ; k++)
                                {

                                    if (  colorPick[i][j][k] == 1 )
                                    {
                                        replicateColorPick[i][j][k] = 1 ;
                                    } ;
                                    if ( i > 0 && colorPick[i-1][j][k] == 1 )
                                    {
                                        replicateColorPick[i][j][k] = 1 ;
                                    } ;
                                    if ( j > 0 &&  colorPick[i][j-1][k] == 1 )
                                    {
                                        replicateColorPick[i][j][k] = 1 ;
                                    } ;
                                    if ( k > 0 &&  colorPick[i][j][k-1] == 1 )
                                    {
                                        replicateColorPick[i][j][k] = 1 ;
                                    } ;
                                    if ( i > 0 && k > 0 && colorPick[i-1][j-1][k] == 1 )
                                    {
                                        replicateColorPick[i][j][k] = 1 ;
                                    } ;
                                    if ( i > 0 && k > 0 &&  colorPick[i-1][j][k-1] == 1 )
                                    {
                                        replicateColorPick[i][j][k] = 1 ;
                                    } ;
                                    if ( j > 0 && j > 0 &&  colorPick[i][j-1][k-1] == 1 )
                                    {
                                        replicateColorPick[i][j][k] = 1 ;
                                    } ;
                                    if ( j > 0 && j > 0 && k > 0 && colorPick[i-1][j-1][k-1] == 1 )
                                    {
                                        replicateColorPick[i][j][k] = 1 ;
                                    } ;
                                    if ( i < sizeColorPick && colorPick[i+1][j][k] == 1 )
                                    {
                                        replicateColorPick[i][j][k] = 1 ;
                                    } ;
                                    if ( j < sizeColorPick && colorPick[i][j+1][k] == 1 )
                                    {
                                        replicateColorPick[i][j][k] = 1 ;
                                    } ;
                                    if ( k < sizeColorPick && colorPick[i][j][k+1] == 1 )
                                    {
                                        replicateColorPick[i][j][k] = 1 ;
                                    } ;
                                    if ( i < sizeColorPick && j < sizeColorPick && colorPick[i+1][j+1][k] == 1 )
                                    {
                                        replicateColorPick[i][j][k] = 1 ;
                                    } ;
                                    if ( i < sizeColorPick && k < sizeColorPick &&  colorPick[i+1][j][k+1] == 1 )
                                    {
                                        replicateColorPick[i][j][k] = 1 ;
                                    } ;
                                    if ( j < sizeColorPick && k < sizeColorPick &&  colorPick[i][j+1][k+1] == 1 )
                                    {
                                        replicateColorPick[i][j][k] = 1 ;
                                    } ;
                                    if ( i < sizeColorPick && j < sizeColorPick && k < sizeColorPick && colorPick[i+1][j+1][k+1] == 1 )
                                    {
                                        replicateColorPick[i][j][k] = 1 ;
                                    } ;
                                    if ( i > 0 && j < sizeColorPick && colorPick[i-1][j+1][k] == 1 )
                                    {
                                        replicateColorPick[i][j][k] = 1 ;
                                    } ;
                                    if ( i > 0 && k < sizeColorPick && colorPick[i-1][j][k+1] == 1 )
                                    {
                                        replicateColorPick[i][j][k] = 1 ;
                                    } ;
                                    if ( j > 0 && k < sizeColorPick &&  colorPick[i][j-1][k+1] == 1 )
                                    {
                                        replicateColorPick[i][j][k] = 1 ;
                                    } ;
                                    if ( i > 0 && j < sizeColorPick && k < sizeColorPick && colorPick[i-1][j+1][k+1] == 1 )
                                    {
                                        replicateColorPick[i][j][k] = 1 ;
                                    } ;
                                    if ( i < sizeColorPick && j > 0 && colorPick[i+1][j-1][k] == 1 )
                                    {
                                        replicateColorPick[i][j][k] = 1 ;
                                    } ;
                                    if ( i < sizeColorPick && k > 0 && colorPick[i+1][j][k-1] == 1 )
                                    {
                                        replicateColorPick[i][j][k] = 1 ;
                                    } ;
                                    if ( j < sizeColorPick && k > 0 &&  colorPick[i][j+1][k-1] == 1 )
                                    {
                                        replicateColorPick[i][j][k] = 1 ;
                                    } ;
                                    if ( i >0 && j>0 && k < sizeColorPick && colorPick[i-1][j-1][k+1] == 1 )
                                    {
                                        replicateColorPick[i][j][k] = 1 ;
                                    } ;
                                    if (  i< sizeColorPick && j >0 && k <sizeColorPick && colorPick[i+1][j-1][k+1] == 1 )
                                    {
                                        replicateColorPick[i][j][k] = 1 ;
                                    } ;

                                }



                            }
                        }

                        // transfert

                        for ( int i = 0 ; i < sizeColorPick ; i++ )
                        {
                            for (int j = 0 ; j < sizeColorPick ; j++ )
                            {
                                for ( int k = 0 ; k < sizeColorPick ; k++)
                                {
                                    colorPick[i][j][k] = replicateColorPick[i][j][k] ; ;
                                }
                            }
                        }


                        SDL_Delay(1000);
                    }


                }
                break;

                case SDLK_f: // Appui sur la touche f, on modife la fréquence de changement d'image : RESET, et si clic modif
                {
                    mode = 'f' ;
                    if ( page == '0')
                    {
                        mode = 'f' ;
                        nextImage = 3;
                        nextImageVariation = 3 ;
                    }


                    if ( page == '1')
                    {
                        mode = 'f';

                        for ( int i = 0 ; i < sizeColorPick ; i++ )
                        {
                            for (int j = 0 ; j < sizeColorPick ; j++ )
                            {
                                for ( int k = 0 ; k < sizeColorPick ; k++)
                                {
                                    colorPick[i][j][k] = 1 ;
                                }
                            }
                        }
                    }
                }
                break;

                case SDLK_g: // Appui sur la touche g, on modife la couleur de transparence
                {
                    mode = 'g' ;

                    if ( page == '0')
                    {
                        transpa = true  ;
                        mode = 'g' ;

                        // TODO DEBUG TY5 : retravailler les transparences
                        // SDL_SetColorKey(impactImage, SDL_SRCCOLORKEY, SDL_MapRGB(impactImage ->format, 0, 0, 0));
                    }

                    if ( page == '1')
                    {
                        mode = 'g';


                    }

                    if ( page == '4')
                    {
                        long long  counter = 0 ;

                        // float Hertz = rand()%5000 + 20 ;
                        float Hertz = rand()%50  + 20 ;
                        float sample = 44100 ; // nombre de pixels dans 1 seconde
                        // float a = truncf( sample / Hertz ) * (rand() % 101) / 100  ;
                        float a =   sample / Hertz     ;

                        cerr << hex ;

                        for ( int i = 0 ; i < maxX  ; i = i+2 )
                        {

                            if ( rand()%100 == 0 )
                            {
                                // changement de valeur
                                Hertz = rand()%850  + 20 ;
                                a =  sample / Hertz  ;
                            }

                            for ( int j = 0 ; j < maxY  ; j++ )
                            {


                                counter++  ;
                                if ( i < 10 )
                                {
                                    cerr << counter << "\t" ;
                                }

                                // float rapport = truncf ( (float) counter / a ) ;
                                // float reste = (float) counter - rapport * a ;

                                float x = (float) counter ;
                                //  if ( i < 10 ) { cerr << x << " : " ; }

                                float value ;

                                float radians =    ((float) x *  (float) PI * (float) 2  ) / ((float) a  )     ;
                                if ( i < 10 )
                                {
                                    cerr  << radians  << "\t" ;
                                }

                                value =  sin(radians ) *   (float) 30000   ; // * (float) 0xFF ;

                                if ( i < 10 )
                                {
                                    cerr  << value << "\t" ;
                                }

                                INT32 realValue = (INT32) ( value   )    ;

                                UINT32  finalfinalValue = realValue ;

                                if ( i < 10 )
                                {
                                    cerr   <<  dec << finalfinalValue << endl  ;
                                }
// image[i][j] = value ;


                                putpixel(gScreenSurface,i,j, finalfinalValue  ) ;
                                putpixel(gScreenSurface,i+1,j, finalfinalValue  ) ;
                                // putpixel(gScreenSurface,i,j, finalfinalValue  ) ;
                            }
                        }
                        SDL_UpdateWindowSurface( gWindow );
                    }


                }
                break ;

                case SDLK_h: // Appui sur la touche h, on réduit une partie de l'écran
                {
                    mode = 'h' ;
                    if ( page == '0')
                    {
                        int x =  rand()% maxX + 1 ;
                        int y =  rand()% maxY +1  ;
                        int w = rand() % ( maxX - x ) + 1 ;
                        int h = rand() % ( maxX - y ) + 1 ;
                        int newx =  rand()% maxX + 1 ;
                        int newy =  rand()% maxY +1  ;

                        for ( int k = 0 ; k < w/2  ; k++)
                        {
                            for ( int m = 0 ; m < h/2  ; m++)
                            {
                                Uint32 pixel  = getpixel(gScreenSurface,(x+k*2)%maxX, (y+m*2)%maxY) ;
                                Uint32 newPixel = pixel  ;
                                putpixel(gScreenSurface,(newx+k)%maxX,(newy+m)%maxY, newPixel  );
                            }
                        }
                        SDL_UpdateWindowSurface( gWindow );
                    }


                    // EXTENSION DE LA PALETTE D'EXCLUSION
                    if ( page == '1')
                    {
                        char replicateColorPick [sizeColorPick][sizeColorPick][sizeColorPick] ;

                        // initialisation

                        for ( int i = 0 ; i < sizeColorPick ; i++ )
                        {
                            for (int j = 0 ; j < sizeColorPick ; j++ )
                            {
                                for ( int k = 0 ; k < sizeColorPick ; k++)
                                {
                                    replicateColorPick[i][j][k] = 1 ;
                                }
                            }
                        }

                        // initialisation

                        for ( int i = 0 ; i < sizeColorPick ; i++ )
                        {
                            for (int j = 0 ; j < sizeColorPick ; j++ )
                            {
                                for ( int k = 0 ; k < sizeColorPick ; k++)
                                {

                                    if (  colorPick[i][j][k] == 0 )
                                    {
                                        replicateColorPick[i][j][k] = 0 ;
                                    } ;
                                    if ( i > 0 && colorPick[i-1][j][k] == 0 )
                                    {
                                        replicateColorPick[i][j][k] = 0 ;
                                    } ;
                                    if ( j > 0 &&  colorPick[i][j-1][k] == 0 )
                                    {
                                        replicateColorPick[i][j][k] = 0 ;
                                    } ;
                                    if ( k > 0 &&  colorPick[i][j][k-1] == 0 )
                                    {
                                        replicateColorPick[i][j][k] = 0 ;
                                    } ;
                                    if ( i > 0 && k > 0 && colorPick[i-1][j-1][k] == 0 )
                                    {
                                        replicateColorPick[i][j][k] = 0 ;
                                    } ;
                                    if ( i > 0 && k > 0 &&  colorPick[i-1][j][k-1] == 0 )
                                    {
                                        replicateColorPick[i][j][k] = 0 ;
                                    } ;
                                    if ( j > 0 && j > 0 &&  colorPick[i][j-1][k-1] == 0 )
                                    {
                                        replicateColorPick[i][j][k] = 0 ;
                                    } ;
                                    if ( j > 0 && j > 0 && k > 0 && colorPick[i-1][j-1][k-1] == 0 )
                                    {
                                        replicateColorPick[i][j][k] = 0 ;
                                    } ;
                                    if ( i < sizeColorPick && colorPick[i+1][j][k] == 0 )
                                    {
                                        replicateColorPick[i][j][k] = 0 ;
                                    } ;
                                    if ( j < sizeColorPick && colorPick[i][j+1][k] == 0 )
                                    {
                                        replicateColorPick[i][j][k] = 0 ;
                                    } ;
                                    if ( k < sizeColorPick && colorPick[i][j][k+1] == 0 )
                                    {
                                        replicateColorPick[i][j][k] = 0 ;
                                    } ;
                                    if ( i < sizeColorPick && j < sizeColorPick && colorPick[i+1][j+1][k] == 0 )
                                    {
                                        replicateColorPick[i][j][k] = 0 ;
                                    } ;
                                    if ( i < sizeColorPick && k < sizeColorPick &&  colorPick[i+1][j][k+1] == 0 )
                                    {
                                        replicateColorPick[i][j][k] = 0 ;
                                    } ;
                                    if ( j < sizeColorPick && k < sizeColorPick &&  colorPick[i][j+1][k+1] == 0 )
                                    {
                                        replicateColorPick[i][j][k] = 0 ;
                                    } ;
                                    if ( i < sizeColorPick && j < sizeColorPick && k < sizeColorPick && colorPick[i+1][j+1][k+1] == 0 )
                                    {
                                        replicateColorPick[i][j][k] = 0 ;
                                    } ;
                                    if ( i > 0 && j < sizeColorPick && colorPick[i-1][j+1][k] == 0 )
                                    {
                                        replicateColorPick[i][j][k] = 0 ;
                                    } ;
                                    if ( i > 0 && k < sizeColorPick && colorPick[i-1][j][k+1] == 0 )
                                    {
                                        replicateColorPick[i][j][k] = 0 ;
                                    } ;
                                    if ( j > 0 && k < sizeColorPick &&  colorPick[i][j-1][k+1] == 0 )
                                    {
                                        replicateColorPick[i][j][k] = 0 ;
                                    } ;
                                    if ( i > 0 && j < sizeColorPick && k < sizeColorPick && colorPick[i-1][j+1][k+1] == 0 )
                                    {
                                        replicateColorPick[i][j][k] = 0 ;
                                    } ;
                                    if ( i < sizeColorPick && j > 0 && colorPick[i+1][j-1][k] == 0 )
                                    {
                                        replicateColorPick[i][j][k] = 0 ;
                                    } ;
                                    if ( i < sizeColorPick && k > 0 && colorPick[i+1][j][k-1] == 0 )
                                    {
                                        replicateColorPick[i][j][k] = 0 ;
                                    } ;
                                    if ( j < sizeColorPick && k > 0 &&  colorPick[i][j+1][k-1] == 0 )
                                    {
                                        replicateColorPick[i][j][k] = 0 ;
                                    } ;
                                    if ( i >0 && j>0 && k < sizeColorPick && colorPick[i-1][j-1][k+1] == 0 )
                                    {
                                        replicateColorPick[i][j][k] = 0 ;
                                    } ;
                                    if (  i< sizeColorPick && j >0 && k <sizeColorPick && colorPick[i+1][j-1][k+1] == 0 )
                                    {
                                        replicateColorPick[i][j][k] = 0 ;
                                    } ;

                                }



                            }
                        }

                        // transfert

                        for ( int i = 0 ; i < sizeColorPick ; i++ )
                        {
                            for (int j = 0 ; j < sizeColorPick ; j++ )
                            {
                                for ( int k = 0 ; k < sizeColorPick ; k++)
                                {
                                    colorPick[i][j][k] = replicateColorPick[i][j][k] ; ;
                                }
                            }
                        }

                        SDL_UpdateWindowSurface( gWindow );
                        SDL_Delay(1000);
                    }




                    if ( page == '4')
                    {
                        long long  counter = 0 ;

                        // float Hertz = rand()%5000 + 20 ;
                        float Hertz = rand()%50  + 20 ;
                        float sample = 44100 ; // nombre de pixels dans 1 seconde
                        // float a = truncf( sample / Hertz ) * (rand() % 101) / 100  ;
                        float a =   sample / Hertz     ;

                        for ( int i = 0 ; i < maxX  ; i = i+2 )
                        {

                            if ( rand()%100 == 0 )
                            {
                                // changement de valeur
                                Hertz = rand()%850  + 20 ;
                                a =  sample / Hertz  ;
                            }

                            for ( int j = 0 ; j < maxY  ; j++ )
                            {
                                counter++  ;
                                // float rapport = truncf ( (float) counter / a ) ;
                                // float reste = (float) counter - rapport * a ;

                                float x = counter ;
                                float value ;

                                // float radians =    ((float) x * (float ) PI * (float) 2  ) / ((float) a  )     ;
                                // float value = ( sin(radians ) *   (float) 0xFFF0 ) / (float) 2   ; // * (float) 0xFF ;

                                int parity = counter /  a ;
                                if (( parity % 2 ) == 0 )
                                {
                                    value = 0xFFFF / 2 ;
                                }
                                else
                                {
                                    value = - 0xFFFF/2 ;
                                }

                                INT16 Nvalue = (INT16) trunc(value);
                                INT32 finalfinalValue = (INT32) Nvalue    ;
// image[i][j] = value ;


                                putpixel(gScreenSurface,i,j, finalfinalValue  ) ;
                                putpixel(gScreenSurface,i+1,j, finalfinalValue  ) ;
                                // putpixel(gScreenSurface,i,j, finalfinalValue  ) ;
                            }
                        }
                        SDL_UpdateWindowSurface( gWindow );
                    }


                }
                break;

                case SDLK_i: // Appui sur la touche i, on blurre
                {
                    mode = 'i' ;
                    if ( page == '0')
                    {
                        int x = rand()% maxX   ;
                        int y = rand()% maxY   ;
                        int taille = rand()%(maxX-x) ;
                        taille = taille % ( maxY - y );


                        Uint32 pixel ;
                        Uint32 moyenne  [taille] = {0}  ;
                        Uint32 moyenneR [taille] = {0} ;
                        Uint32 moyenneG [taille] = {0};
                        Uint32 moyenneB [taille]  = {0} ;

                        for (int i = 0 ; i < taille ; i++ )

                        {
                            moyenne[i] = 0 ;
                            moyenneR[i] = 0 ;
                            moyenneG[i] = 0 ;
                            moyenneB[i] = 0   ;

                            for (int j = 0 ; j < taille ; j++ )
                            {
                                pixel = getpixel(gScreenSurface,x+i,y+j);
                                moyenneR[i] += (( pixel >>16 ) & 0xFF ) ;
                                moyenneG[i] += (( pixel >>8 ) & 0xFF ) ;
                                moyenneB[i] += ((pixel >>0 ) & 0xFF ) ;

                            }

                            // moyenne[i] = moyenne[i]/ taille ;
                            moyenneR[i] /= taille  ;
                            moyenneG[i] /= taille  ;
                            moyenneB[i] /= taille  ;

                            for (int j = 0 ; j < taille ; j++ )
                            {
                                if ( x+i < maxX && y+j < maxY && x+i > 0 && y+j > 0 )
                                {
                                    putpixel(gScreenSurface,x+i,y+j,(moyenneR[i]<<16)+(moyenneG[i]<<8)+(moyenneB[i]<<0));
                                }
                            }

                        }

                        SDL_UpdateWindowSurface( gWindow );
                    }


                    if ( page == '1')
                    {
                        int x =  rand()% maxX + 1 ;
                        int y =  rand()% maxY +1  ;
                        int w = rand() % ( maxX - x ) + 1 ;
                        int h = rand() % ( maxX - y ) + 1 ;
                        int newx =  rand()% maxX + 1 ;
                        int newy =  rand()% maxY +1  ;
                        int newW = w + rand() % ( maxX - w ) + 1 ;

                        int taille[w];
                        for ( int i = 0 ; i < w ; i++)
                        {
                            taille[i] = 1 ; // par défaut, à l'identique, on recopiera chaque colonne 1x
                        }

                        long cumul = 0 ;
                        do
                        {
                            cumul = 0 ;
                            taille[rand()%w] += rand()%2 * 5 ;

                            for ( int i = 0 ; i < w ; i++)
                            {
                                cumul += taille[i]  ;
                            }
                        }
                        while (cumul < newW ) ; // autrement dit : on rajouter 1 colonne à la nouvelle image jusqu'à la bonne taille

                        int marqueur = 0 ;

                        for ( int i = 0 ; i < w ; i++ )
                        {
                            for ( int j = 0 ; j < taille[i] ; j++ )
                            {
                                // copier ligne
                                for ( int k = 0 ; k < h ; k++ )
                                {
                                    // copier point x,y -> newX, newY
                                    // x,y  -> newx, newy
                                    // x+i,y+k -> newx+marqueur+j,newy+k
                                    Uint32 pixel  = getpixel(gScreenSurface,(x+i)%maxX, (y+k)%maxY) ;
                                    Uint32 newPixel = pixel  ;
                                    putpixel(gScreenSurface,(newx+marqueur+j)%maxX,(newy+k)%maxY, newPixel  );
                                }

                            }
                            marqueur += taille[i];
                        }

                        SDL_UpdateWindowSurface( gWindow );
                        SDL_Delay(100);
                    }



                    if ( page == '2')
                    {
                        // spectrum display
                        int x = rand()% maxX   ;
                        int y = rand()% maxY   ;
                        int taille = rand()%(maxX-x) ;
                        taille = taille % ( maxY - y );

                        Uint32 pixel = 0 ;
                        int minValueR = rand()%255;
                        int maxValueR= rand()%255;
                        if ( minValueR > maxValueR )
                        {
                            swap(minValueR,maxValueR) ;
                        }

                        int  minValueG = rand()%255;
                        int maxValueG= rand()%255;
                        if ( minValueG > maxValueG )
                        {
                            swap(minValueG,maxValueG) ;
                        }

                        int  minValueB = rand()%255;
                        int maxValueB= rand()%255;
                        if ( minValueB > maxValueB )
                        {
                            swap(minValueB,maxValueB) ;
                        }


                        int a = rand()%3 *8 ;   // soit 0, 8 ou 16
                        int b = rand()%3 * 8 ;
                        int c = rand()%3 *8 ;   // soit 0, 8 ou 16


                        for (int i = 0 ; i < taille ; i++ )
                        {
                            for (int j = 0 ; j < taille ; j++ )
                            {
                                // pixel = rand()%255 << 16 + rand()%255 << 8 + rand()%255 << 0 ;
                                // pixel = ( (i % 255) << 16 ) + (( j % 255 ) << 8 ) + ( ( i+j) % 255 ) ;
// pixel = ((( i * 255 / taille ) % 255 ) << 16 ) + ((( j * 255 / taille ) % 255 ) << 0 ) ;
                                pixel = ((( i * ( maxValueR - minValueR ) / taille ) % 255 ) << a )
                                        + ((( j *( maxValueG - minValueG ) / taille ) % 255 ) << b )
                                        + ((( (i+j) *( maxValueB - minValueB ) / taille ) % 255 ) << c )
                                        ;

                                if ( x+i < maxX && y+j < maxY && x+i > 0 && y+j > 0 )
                                {
                                    putpixel(gScreenSurface,x+i,y+j,pixel);
                                }
                            }
                        }
                    }


                    if ( page == '3')    // modif couleurs
                    {
                        int x =  rand()% maxX + 1 ;
                        int y =  rand()% maxY +1  ;
                        int w = rand() % ( maxX - x ) + 1 ;
                        int h = rand() % ( maxX - y ) + 1 ;


                        for ( int i = 0 ; i < w ; i++ )
                        {
                            for ( int j = 0 ; j < h ; j++ )
                            {

                                {
                                    Uint32 pixel  = getpixel(gScreenSurface,(x+i)%maxX, (y+j)%maxY) ;
                                    Uint32 newPixel = pixel  ;
                                    Uint32 Green = ( pixel >> 16  ) & 0xFF ;
                                    Uint32 Red = ( pixel >> 8  ) & 0xFF ;
                                    Uint32 Blue = ( pixel >> 0 ) & 0xFF ;

                                    // newPixel = Blue << 16 + Green << 8 + Red ;

                                    /*
                                    newPixel = ( Green + rand()%10 - rand()%10 ) << 16
                                    + ( Red + rand()%10 - rand()%10 ) << 8
                                    + ( Blue + rand()%10 - rand()%10 ) << 0 ;
                                    */

                                    newPixel = Green << 16 + Blue ;

                                    putpixel(gScreenSurface,(x+i)%maxX,(y+j)%maxY, newPixel  );
                                }

                            }

                        }

                        SDL_UpdateWindowSurface( gWindow );
                        SDL_Delay(100);
                    }






                }
                break;


                case SDLK_j: // Appui sur la touche j, on modifie les couleurs
                {
                    mode = 'j' ;
                    if ( page == '0')    // modif couleurs
                    {

                        int x = rand()% maxX / 2 ;
                        int y = rand()% maxY / 2 ;
                        int taille = rand()%(maxX-x) ;
                        taille = taille % ( maxY - y );

                        UINT32 pixel ;

                        for (int i = 0 ; i < taille ; i++ )
                        {
                            for (int j = 0 ; j < taille ; j++ )
                            {
                                if ( x+i < maxX && y+j < maxY && x+i > 0 && y+j > 0 )
                                {
                                    pixel = getpixel(gScreenSurface,x+i,y+j);
                                    pixel = ( pixel >> 8 ) << 8 ;
                                    putpixel(gScreenSurface,x+i,y+j,pixel);
                                }
                            }
                        }

                        SDL_UpdateWindowSurface( gWindow );
                    }

                    if ( page == '1')    // modif couleurs
                    {

                        int x = rand()% maxX / 2 ;
                        int y = rand()% maxY / 2 ;
                        int taille = rand()%(maxX-x) ;
                        taille = taille % ( maxY - y );

                        UINT32 pixel ;

                        for (int i = 0 ; i < taille ; i++ )
                        {
                            for (int j = 0 ; j < taille ; j++ )
                            {
                                if ( x+i < maxX && y+j < maxY && x+i > 0 && y+j > 0 )
                                {
                                    pixel = getpixel(gScreenSurface,x+i,y+j);
                                    pixel = pixel & 0xFF00FF ;
                                    putpixel(gScreenSurface,x+i,y+j,pixel);
                                }
                            }
                        }

                        SDL_UpdateWindowSurface( gWindow );
                    }

                    if ( page == '2')    // modif couleurs
                    {

                        int x = rand()% maxX / 2 ;
                        int y = rand()% maxY / 2 ;
                        int taille = rand()%(maxX-x) ;
                        taille = taille % ( maxY - y );

                        UINT32 pixel ;

                        for (int i = 0 ; i < taille ; i++ )
                        {
                            for (int j = 0 ; j < taille ; j++ )
                            {
                                if ( x+i < maxX && y+j < maxY && x+i > 0 && y+j > 0 )
                                {
                                    pixel = getpixel(gScreenSurface,x+i,y+j);
                                    pixel = pixel & 0x00FFFF ;
                                    putpixel(gScreenSurface,x+i,y+j,pixel);
                                }
                            }
                        }

                        SDL_UpdateWindowSurface( gWindow );
                    }

                    if ( page == '3')    // modif couleurs
                    {

                        int x = rand()% maxX / 2 ;
                        int y = rand()% maxY / 2 ;
                        int taille = rand()%(maxX-x) ;
                        taille = taille % ( maxY - y );

                        UINT32 pixel ;

                        for (int i = 0 ; i < taille ; i++ )
                        {
                            for (int j = 0 ; j < taille ; j++ )
                            {
                                if ( x+i < maxX && y+j < maxY && x+i > 0 && y+j > 0 )
                                {
                                    pixel = getpixel(gScreenSurface,x+i,y+j);
                                    pixel = pixel ^ 0xFFFFFF ;
                                    putpixel(gScreenSurface,x+i,y+j,pixel);
                                }
                            }
                        }

                        SDL_UpdateWindowSurface( gWindow );
                    }

                }
                break;

                case SDLK_k: // Appui sur la touche k, on passe en mode échiquier
                {
                    mode = 'k' ;
                    modeChess = ! modeChess ;
                }
                break;


                case SDLK_l: // Appui sur la touche l, on faitun black out
                {
                    mode = 'l' ;
                       if ( page == '0' )
                    {
                    for ( int r = 0 ; r < 20 ; r++ )
                    {

                        int x = rand()% maxX  ;
                        int y = rand()% maxY  ;
                        int taille = rand()%(maxX-x) ;
                        taille = taille % ( maxY - y );
                        taille = taille % 300 ;

                        UINT32 pixel ;

                        for (int i = 0 ; i < taille ; i++ )
                        {
                            for (int j = 0 ; j < taille ; j++ )
                            {
                                if ( x+i < maxX && y+j < maxY && x+i > 0 && y+j > 0 )
                                {

                                    putpixel(gScreenSurface,x+i,y+j,0);
                                }
                            }
                        }
                    }

                    SDL_UpdateWindowSurface( gWindow );
                    }

                    if ( page == '1')
                    /** \brief
                     *
                     * \param
                     * \param
                     * \return
                     *
                     */
                    {
                      findHomogenousUnder(25);
                      paintMasque(100,100,100,0);
                         SDL_UpdateWindowSurface( gWindow );
                    }


                    if ( page == '2')
                    {
                      findHomogenousUnder(25);
                      invertMasque();
                      paintMasque(100,100,100,0);
                         SDL_UpdateWindowSurface( gWindow );
                    }
                }
                break;

                case SDLK_m: // Appui sur la touche m, on blurre
                {
                    mode = 'm' ;
                    if ( page == '0' )
                    {
                        int x = rand()% maxX / 2 + 10 ;
                        int y = rand()% maxY / 2 + 10 ;

                        int taille = rand()%(maxX-x) ;
                        taille = taille % ( maxY - y );
                        taille = taille % 1800 + 100 ;

                        UINT32 pixel ;
                        int scope = rand()%150+ 5;

                        for (int i = x ; i <= x+taille ; i++ )
                        {
                            long previousSuperficie = 0 ;
                            Uint32 moyenneR  =0 ;
                            Uint32 moyenneG  = 0;
                            Uint32 moyenneB   =0 ;
                            Uint32 totalR  =0 ;
                            Uint32 totalG  = 0;
                            Uint32 totalB   =0 ;
                            long superficie = 0 ;

                            for (int j = y ; j <= y+taille ; j++ )
                            {
                                if ( j == y )
                                {
                                    // calcul pour le premier pixel

                                    for ( int t = i-scope ; t <= i+scope ; t++ )
                                    {
                                        for ( int u = j-scope ; u <= j+scope ; u++)
                                        {
                                            if ( t > 0 && t < maxX && u > 0 && u < maxY )
                                            {
                                                pixel = getpixel(gScreenSurface,t,u);
                                                superficie++ ;

                                                totalR += (( pixel >>16 ) & 0xFF ) ;
                                                totalG += (( pixel >>8 ) & 0xFF ) ;
                                                totalB += ((pixel >>0 ) & 0xFF ) ;
                                            }
                                        }
                                    }

                                    if ( superficie != 0 )
                                    {
                                        moyenneR = totalR / superficie ;
                                        moyenneG = totalG / superficie ;
                                        moyenneB = totalB / superficie ;
                                    }
                                    previousSuperficie = superficie ;
                                }
                                else
                                {
                                    // calcul pour les pixels suivants :
                                    // on calcule le total pour la dernière ligne
                                    // et on rajoute la superficie
                                    // on calcule le total pour la premiere ligne
                                    // et on retire la superficie
                                    for ( int t = i-scope ; t <= i+scope ; t++ )
                                    {
                                        int u =  j+scope ;
                                        {
                                            if ( t > 0 && t < maxX && u > 0 && u < maxY )
                                            {
                                                pixel = getpixel(gScreenSurface,t,u);
                                                previousSuperficie++ ;

                                                totalR += (( pixel >>16 ) & 0xFF ) ;
                                                totalG += (( pixel >>8 ) & 0xFF ) ;
                                                totalB += ((pixel >>0 ) & 0xFF ) ;
                                            }
                                        }

                                        u = j-scope-1 ;
                                        {
                                            if ( t > 0 && t < maxX && u > 0 && u < maxY )
                                            {
                                                pixel = getpixel(gScreenSurface,t,u);
                                                previousSuperficie-- ;

                                                totalR -= (( pixel >>16 ) & 0xFF ) ;
                                                totalG -= (( pixel >>8 ) & 0xFF ) ;
                                                totalB -= ((pixel >> 0 ) & 0xFF ) ;
                                            }
                                        }
                                    }

                                    if ( previousSuperficie != 0 )
                                    {
                                        moyenneR = totalR / previousSuperficie ;
                                        moyenneG = totalG / previousSuperficie ;
                                        moyenneB = totalB / previousSuperficie ;
                                    }
                                }


                                if ( i < maxX && j < maxY && i > 0 && j > 0 )
                                {
                                    putpixel(gScreenSurface,i,j,(moyenneR <<16)+(moyenneG <<8)+(moyenneB <<0 ) );
                                }
                            }
                        }

                        SDL_UpdateWindowSurface( gWindow );
                    }

                    if ( page == '1' )    // RICHTER 2021
                    {
                        int x = rand()% ( maxX - 1 )  ;
                        int y = rand()% ( maxY - 1 )  ;

                        int taille = rand()%(maxX - x) ;

                        UINT32 pixel ;

                        while ( x+taille >= maxX )
                        {
                            taille -- ;
                        }

                        for (int i = x ; i <= x+taille ; i++ )
                        {
                            UINT32 hauteur = rand()%(maxY - y );
                            hauteur = 300 ;
                            // hauteur = hauteur + rand()%20 - rand()% 20 ;
                            if (hauteur <= 0)
                            {
                                hauteur = 1 ;
                            }
//                        if ( y + hauteur > maxY ) { hauteur = maxY - y ; }

                            while ( y+hauteur >= maxY )
                            {
                                hauteur -- ;
                            }

//                       long previousSuperficie = 0 ;
                            Uint32 moyenneR  =0 ;
                            Uint32 moyenneG  = 0;
                            Uint32 moyenneB   =0 ;
                            Uint32 totalR  =0 ;
                            Uint32 totalG  = 0;
                            Uint32 totalB   =0 ;
                            Uint32 initR = 0 ;
                            Uint32 initG = 0 ;
                            Uint32 initB = 0 ;

                            //                     long superficie = 0 ;

                            pixel = getpixel(gScreenSurface,i,y);

                            initR = (( pixel >>16 ) & 0xFF ) ;
                            initG = (( pixel >>8 ) & 0xFF ) ;
                            initB = ((pixel >>0 ) & 0xFF ) ;

                            UINT32 pixelInit = pixel ;

                            //                        cout << "spectrum" << endl ;
                            //                      cout << initR << " " << initG << " " << initB << endl ;

                            for (int j = y ; j <= y+ hauteur ; j++ )
                            {
                                pixel = getpixel(gScreenSurface,i,j);
                                totalR += (( pixel >>16 ) & 0xFF ) ;
                                totalG += (( pixel >>8 ) & 0xFF ) ;
                                totalB += ((pixel >>0 ) & 0xFF ) ;
                            }

                            moyenneR = totalR / hauteur  ;
                            moyenneG = totalG / hauteur ;
                            moyenneB = totalB / hauteur  ;

                            Uint32 pixelFinal = (moyenneR <<16)+(moyenneG <<8)+(moyenneB <<0 ) ;

                            Uint32 differenceR = moyenneR - initR ;
                            Uint32 differenceG = moyenneG - initG ;
                            Uint32 differenceB = moyenneB - initB ;

//                            cout << moyenneR << " " << moyenneG << " " << moyenneB << endl ;
                            //                          cout << "makes" << endl ;

                            for (int  j = y ; j <= y+ hauteur ; j++ )
                            {
                                UINT32 nowR, nowG, nowB = 0 ;
                                Uint32 distance = j-y ;

                                UINT32 accuStepR =  ( ( moyenneR - initR) * distance  ) / hauteur ;
                                nowR = initR + accuStepR ;

                                UINT32 accuStepG =  ( ( moyenneG - initG) *  distance  ) / hauteur ;
                                nowG = initG + accuStepG ;

                                UINT32 accuStepB =  ( ( moyenneB - initB) *  distance ) / hauteur ;
                                nowB = initB + accuStepB ;


                                //  nowR = moyenneR ;
                                //  nowG = moyenneG ;
                                //  nowB = moyenneB ;

// nowR = initR ;
// nowG = initG ;
// nowB = initB ;

                                nowR = initR + differenceR * distance / hauteur  ;
                                nowG = initG + differenceG * distance / hauteur ;
                                nowB = initB + differenceB * distance / hauteur  ;

// if ( j == y )
                                {

                                    //        cout << nowR << " " << nowG << " " << nowB << endl ;
                                }
                                UINT32 meanPixel = pixelInit + ((pixelFinal-pixelInit) * distance ) / hauteur ;

//                                putpixel(gScreenSurface,i,j,(nowR <<16)+(nowG <<8)+(nowB <<0 ) );
                                putpixel(gScreenSurface,i,j, meanPixel );
                            }
                            //  SDL_Delay(2000);
                        }

                        SDL_UpdateWindowSurface( gWindow );

                    }


                    if ( page == '2' )    // RICHTER 2021
                    {
                        int x = rand()% ( maxX - 1 )  ;
                        int y = rand()% ( maxY - 1 )  ;

                        int taille = rand()%(maxX - x) ;

                        UINT32 pixel ;

                        while ( x+taille >= maxX )
                        {
                            taille -- ;
                        }

                        for (int i = x ; i <= x+taille ; i++ )
                        {
                            UINT32 hauteur = rand()%(maxY - y );

                            if (hauteur <= 0)
                            {
                                hauteur = 1 ;
                            }

                            while ( y+hauteur >= maxY )
                            {
                                hauteur -- ;
                            }

                            Uint32 moyenneR  =0 ;
                            Uint32 moyenneG  = 0;
                            Uint32 moyenneB   =0 ;
                            Uint32 totalR  =0 ;
                            Uint32 totalG  = 0;
                            Uint32 totalB   =0 ;
                            Uint32 initR = 0 ;
                            Uint32 initG = 0 ;
                            Uint32 initB = 0 ;
                            Uint32 initAlpha = 0 ;

                            pixel = getpixel(gScreenSurface,i,y);

                            initR = (( pixel >>16 ) & 0xFF ) ;
                            initG = (( pixel >>8 ) & 0xFF ) ;
                            initB = ((pixel >>0 ) & 0xFF ) ;
                            initAlpha = (pixel >> 24 ) & 0xFF ;
                            UINT32 pixelInit = pixel ;

                            for (int j = y ; j <= y+ hauteur ; j++ )
                            {
                                pixel = getpixel(gScreenSurface,i,j);
                                totalR += (( pixel >>16 ) & 0xFF ) ;
                                totalG += (( pixel >>8 ) & 0xFF ) ;
                                totalB += ((pixel >>0 ) & 0xFF ) ;
                            }

                            moyenneR = totalR / hauteur  ;
                            moyenneG = totalG / hauteur ;
                            moyenneB = totalB / hauteur  ;


                            pixel = getpixel(gScreenSurface,i,y+hauteur);
                            moyenneR = ( pixel >> 16 ) & 0xFF ;
                            moyenneG = ( pixel >> 8 ) & 0xFF ;
                            moyenneB = ( pixel >> 0 ) & 0xFF ;

                            Uint32 differenceR = moyenneR - initR ;
                            Uint32 differenceG = moyenneG - initG ;
                            Uint32 differenceB = moyenneB - initB ;

                            for (int  j = y ; j <= y+ hauteur ; j++ )
                            {
                                UINT32 nowR, nowG, nowB = 0 ;
                                Uint32 distance = j-y ;

                                UINT32 accuStepR =  ( ( moyenneR - initR) * distance  ) / hauteur ;
                                nowR = initR + accuStepR ;

                                UINT32 accuStepG =  ( ( moyenneG - initG) *  distance  ) / hauteur ;
                                nowG = initG + accuStepG ;

                                UINT32 accuStepB =  ( ( moyenneB - initB) *  distance ) / hauteur ;
                                nowB = initB + accuStepB ;

                                putpixel(gScreenSurface,i,j,(initAlpha << 24) + (nowR <<16)+(nowG <<8)+(nowB <<0 ) );
                                //vputpixel(gScreenSurface,i,j,pixel  );

                            }

                        }

                        SDL_UpdateWindowSurface( gWindow );

                    }



                    if ( page == '3' )    // MARKOV 2021
                    {
                        int index = 0 ;

                        int x = rand()% ( maxX - 1 )  ;
                        int y = rand()% ( maxY - 1 )  ;

                        int taille = rand()%(maxX - x) ;

                        UINT32 pixel ;

                        while ( x+taille >= maxX )
                        {
                            taille -- ;
                        }

                        UINT32 hauteur = rand()%(maxY - y );

                        if (hauteur <= 0)
                        {
                            hauteur = 1 ;
                        }

                        while ( y+hauteur >= maxY )
                        {
                            hauteur -- ;
                        }

                        const int tailleMarkov = 30 ;
                        UINT32 markov[tailleMarkov];

                        for (int i = x ; i <= x+taille ; i++ )
                        {

                            UINT32 pixelInit = pixel ;

                            for (int j = y ; j <= y+ hauteur ; j++ )
                            {
                                pixel = getpixel(gScreenSurface,i,j);

                                if ( index < tailleMarkov )
                                {
                                    markov[index] = pixel ;
                                    index++ ;
                                    int choice = rand()%index ;
                                    putpixel(gScreenSurface,i,j,markov[choice]);
                                }

                                if ( index >= tailleMarkov )
                                {
                                    // plus besoin de l'augmenter il est à tailleMarkov pour de bon
                                    int choice = rand()%index ;
                                    putpixel(gScreenSurface,i,j,markov[choice]);
                                    markov[choice]= pixel ;
                                }

                            }

                        }

                        SDL_UpdateWindowSurface( gWindow );
                    }



                    if ( page == '4' )    // COLOR SPLASH 2021
                    {
                        int index = 0 ;

                        int x = rand()% ( maxX - 1 )  ;
                        int y = rand()% ( maxY - 1 )  ;

                        x = 0 ;
                        y = 0 ;

                        int taille = rand()%(maxX - x) ;

                        taille =  maxX ;

                        UINT32 pixel ;

                        while ( x+taille >= maxX )
                        {
                            taille -- ;
                        }

                        UINT32 hauteur = rand()%(maxY - y );

                        hauteur = maxY ;

                        if (hauteur <= 0)
                        {
                            hauteur = 1 ;
                        }

                        while ( y+hauteur >= maxY )
                        {
                            hauteur -- ;
                        }

                        UINT32 shiftR = rand()%256 ;
                        UINT32 shiftG = rand()%256 ;
                        UINT32 shiftB = rand()%256 ;
                        UINT32 shiftU = rand()%256 ;

                        for (int i = x ; i <= x+taille ; i++ )
                        {

                            UINT32 pixelInit = pixel ;

                            for (int j = y ; j <= y+ hauteur ; j++ )
                            {
                                pixel = getpixel(gScreenSurface,i,j);

                                UINT32 pixelR = ( pixel >> 0 ) & 0xFF ;
                                UINT32 pixelG = ( pixel >> 8 ) & 0xFF ;
                                UINT32 pixelB = ( pixel >> 16 ) & 0xFF ;
                                UINT32 pixelU = ( pixel >> 24 ) & 0xFF ;

                                pixelR += shiftR ;
                                pixelR = pixelR % 256 ;
                                pixelG += shiftG ;
                                pixelG = pixelG % 256 ;
                                pixelB += shiftB ;
                                pixelB = pixelB % 256 ;
                                pixelU += shiftU ;
                                pixelU = pixelU % 256 ;

                                pixel = pixelR + ( pixelG << 8 ) + ( pixelB << 16 ) + ( pixelU << 24 ) ;

                                putpixel(gScreenSurface,i,j,pixel);
                            }

                        }

                        SDL_UpdateWindowSurface( gWindow );
                    }

                    if ( page == '5' )    // INVERTER 2021
                    {
                        int index = 0 ;

                        int x = rand()% ( maxX - 1 )  ;
                        int y = rand()% ( maxY - 1 )  ;

                        x = 0 ;
                        y = 0 ;

                        int taille = rand()%(maxX - x) ;

                        taille =  maxX ;

                        UINT32 pixel ;

                        while ( x+taille >= maxX )
                        {
                            taille -- ;
                        }

                        UINT32 hauteur = rand()%(maxY - y );

                        hauteur = maxY ;

                        if (hauteur <= 0)
                        {
                            hauteur = 1 ;
                        }

                        while ( y+hauteur >= maxY )
                        {
                            hauteur -- ;
                        }

//                            UINT32 shiftR = rand()%256 ;
                        //                          UINT32 shiftG = rand()%256 ;
                        //                        UINT32 shiftB = rand()%256 ;
                        //                      UINT32 shiftU = rand()%256 ;

                        bool moveR = rand() % 2 == 0 ? true : false ;
                        bool moveG = rand() % 2 == 0 ? true : false ;
                        bool moveB = rand() % 2 == 0 ? true : false ;
                        bool moveU = rand() % 2 == 0 ? true : false ;

                        for (int i = x ; i <= x+taille ; i++ )
                        {

                            UINT32 pixelInit = pixel ;

                            for (int j = y ; j <= y+ hauteur ; j++ )
                            {
                                pixel = getpixel(gScreenSurface,i,j);

                                UINT32 pixelR = ( pixel >> 0 ) & 0xFF ;
                                UINT32 pixelG = ( pixel >> 8 ) & 0xFF ;
                                UINT32 pixelB = ( pixel >> 16 ) & 0xFF ;
                                UINT32 pixelU = ( pixel >> 24 ) & 0xFF ;

                                if (moveR == true )
                                {
                                    pixelR = 255 - pixelR ;
                                } ;
                                pixelR = pixelR % 256 ;
                                if (moveG == true )
                                {
                                    pixelG = 255 - pixelG ;
                                } ;
                                pixelG = pixelG % 256 ;
                                if (moveB == true )
                                {
                                    pixelB = 255 - pixelB ;
                                } ;
                                pixelB = pixelB % 256 ;
                                if (moveU == true )
                                {
                                    pixelU = 255 - pixelU ;
                                } ;
                                pixelU = pixelU % 256 ;


                                pixel = pixelR + ( pixelG << 8 ) + ( pixelB << 16 ) + ( pixelU << 24 ) ;

                                putpixel(gScreenSurface,i,j,pixel);
                            }

                        }

                        SDL_UpdateWindowSurface( gWindow );
                    }

                    if ( page == '6' )    // TURNER 2021
                    {
                        int index = 0 ;

                        int x = rand()% ( maxX - 1 )  ;
                        int y = rand()% ( maxY - 1 )  ;

                        x = 0 ;
                        y = 0 ;

                        int taille = rand()%(maxX - x) ;

                        taille =  maxX ;

                        UINT32 pixel ;

                        while ( x+taille >= maxX )
                        {
                            taille -- ;
                        }

                        UINT32 hauteur = rand()%(maxY - y );

                        hauteur = maxY ;

                        if (hauteur <= 0)
                        {
                            hauteur = 1 ;
                        }

                        while ( y+hauteur >= maxY )
                        {
                            hauteur -- ;
                        }

                        int moveIt [4];
                        for (int i = 0 ; i < 4 ; i++)
                        {
                            moveIt[i]= rand()%4 ;
                        }

                        for (int i = x ; i < x+taille ; i++ )
                        {

                            UINT32 pixelInit = pixel ;

                            for (int j = y ; j < y+ hauteur ; j++ )
                            {
                                pixel = getpixel(gScreenSurface,i,j);

                                UINT32 pixelR [4] = {0};

                                pixelR [0] = ( pixel >> 0 ) & 0xFF ;
                                pixelR [1] = ( pixel >> 8 ) & 0xFF ;
                                pixelR [2]= ( pixel >> 16 ) & 0xFF ;
                                pixelR [3]= ( pixel >> 24 ) & 0xFF ;

                                UINT32 nupixel [4] = {0};

                                for (int i = 0 ; i < 4 ; i++ )
                                {
                                    nupixel[i]= pixelR[moveIt[i]] ;
                                }




                                pixel = nupixel[0] + ( nupixel[1] << 8 ) + ( nupixel[2] << 16 ) + ( nupixel[3] << 24 ) ;

                                putpixel(gScreenSurface,i,j,pixel);
                            }

                        }

                        SDL_UpdateWindowSurface( gWindow );
                    }



                    if ( page == '7' )    // RICHTER XMAS
                    {
                        int x = rand()% ( maxX - 1 ) /2  ;
                        int y = rand()% ( maxY - 1 )  /2 ;

                        int taille = rand()%(maxX - x) ;

                        UINT32 pixel ;

                        while ( x+taille >= maxX )
                        {
                            taille -- ;
                        }

                        for (int i = x ; i <=  x+taille ; i++ )
                        {
                            UINT32 hauteur = rand()%(maxY - y );

                            if (hauteur <= 0)
                            {
                                hauteur = 1 ;
                            }

                            while ( y+hauteur >= maxY )
                            {
                                hauteur -- ;
                            }

                            Uint32 moyenneR  =0 ;
                            Uint32 moyenneG  = 0;
                            Uint32 moyenneB   =0 ;
                            Uint32 totalR  = 0 ;
                            Uint32 totalG  = 0;
                            Uint32 totalB   = 0 ;

Uint32 initPixel = 0 ;

                            pixel = getpixel(gScreenSurface,i,y);
initPixel = pixel ;
initPixel = initPixel & 0xFFFFFF ;

                            for (int j = y ; j <=  y+ hauteur ; j++ )
                            {
                                pixel = getpixel(gScreenSurface,i,j);
                                totalR += (( pixel >>16 ) & 0xFF ) ;
                                totalG += (( pixel >>8 ) & 0xFF ) ;
                                totalB += ((pixel >>0 ) & 0xFF ) ;
                            }

                            moyenneR = totalR / hauteur  ;
                            moyenneG = totalG / hauteur ;
                            moyenneB = totalB / hauteur  ;

                            Uint32 color2 = ( moyenneR << 16) + (moyenneG << 8 ) + moyenneB ;

                            for (int  j = y ; j <=  y+ hauteur ; j++ )
                            {
                                Uint32 intermed = intermediateColor(initPixel,color2,(float)(((j-y)*100)/hauteur));

                                putpixel(gScreenSurface,i,j,intermed );
                            }
                        }
                        SDL_UpdateWindowSurface( gWindow );

                    }



                    if ( page == '8' )    // SPECTRUM SPLASH
                    {
                        int x = rand()% ( maxX - 1 )  ;
                        int y = rand()% ( maxY - 1 )  ;

                        Uint32 color1 = ((rand()%(0xFF+1)) << 16 ) + ((rand()%(0xFF+1)) <<  8) + (rand()%(0xFF+1)) ; // crée couleur au hasard
                        Uint32 color2 = ((rand()%(0xFF+1)) << 16 )+ ((rand()%(0xFF+1)) << 8) + (rand()%(0xFF+1) ); // crée couleur au hasard
                        Uint32 color3 = ((rand()%(0xFF+1)) << 16 )+ ((rand()%(0xFF+1)) << 8) + (rand()%(0xFF+1) ); // crée couleur au hasard
                        Uint32 color4 = ((rand()%(0xFF+1)) << 16 )+ ((rand()%(0xFF+1)) << 8) + (rand()%(0xFF+1) ); // crée couleur au hasard

                        color1 = 0xFFFFFF ;
color2 = 0x000000;
cout << hex << color3 << " " << color4 << dec << endl ;

                        int taille = rand()%(maxX - x) ;

                        UINT32 pixel ;

                        while ( x+taille >= maxX )
                        {
                            taille -- ;
                        }

                         UINT32 hauteur = rand()%(maxY - y );

                            if (hauteur <= 0)
                            {
                                hauteur = 1 ;
                            }

                            while ( y+hauteur >= maxY )
                            {
                                hauteur -- ;
                            }

                            x = 20 ;
                            y = 20 ;
                            taille = 600 ;
                            hauteur = 600 ;

                        for (int i = x ; i <= x+taille ; i++ )
                        {
                            for (int  j = y ; j <=  y+ hauteur ; j++ )
                            {
                                float percent1 = ((float) (i-x) * (float) 100 ) / (float) taille ;
                                float percent2 = ((float) (j-y) * (float) 100 ) / (float) hauteur ;
                              //  cout << percent2 << endl ;

                                 Uint32 intermed1 = intermediateColor(color1,color2, percent1 );
                                Uint32 intermed2 = intermediateColor(color3,color4, percent1 );
                                Uint32 intermed3 = intermediateColor(intermed1,intermed2, percent2 );
                                // Uint32 intermed3 = intermediateColor(color3,color4, percent1 );

                                putpixel(gScreenSurface,i,j,intermed3 );
                            }

                        }

                        SDL_UpdateWindowSurface( gWindow );
                    }

              if ( page == 9 )  // RGB description
              {

              }


                }

                break ;


                case SDLK_n: // Appui sur la touche n, on détruit
                {

                    mode = 'n' ;
                    if ( page == '0' )
                    {
                    int x = rand()% maxX / 2 + 10 ;
                    int y = rand()% maxY / 2 + 10 ;

                    int taille = rand()%(maxX-x) ;
                    taille = taille % ( maxY - y );
                    taille = taille % 1800 + 100 ;

                    UINT32 pixel ;
                    int scope = rand()%150+ 5;

                    int shifta = rand() % 16 ;
                    int shiftb = rand() % 16 ;
                    int shiftc = rand() % 16 ;

                    for (int i = x ; i <= x+taille ; i++ )
                    {
                        long previousSuperficie = 0 ;
                        Uint32 moyenneR  =0 ;
                        Uint32 moyenneG  = 0;
                        Uint32 moyenneB   =0 ;
                        Uint32 totalR  =0 ;
                        Uint32 totalG  = 0;
                        Uint32 totalB   =0 ;
                        long superficie = 0 ;

                        for (int j = y ; j <= y+taille ; j++ )
                        {
                            if ( j == y )
                            {
                                // calcul pour le premier pixel

                                for ( int t = i-scope ; t <= i+scope ; t++ )
                                {
                                    for ( int u = j-scope ; u <= j+scope ; u++)
                                    {
                                        if ( t > 0 && t < maxX && u > 0 && u < maxY )
                                        {
                                            pixel = getpixel(gScreenSurface,t,u);
                                            superficie++ ;

                                            totalR += (( pixel >> ( shifta ) ) & 0xFF ) ;
                                            totalG += (( pixel >>( shiftb )) & 0xFF ) ;
                                            totalB += ((pixel >>( shiftc)) & 0xFF ) ;
                                        }
                                    }
                                }

                                if ( superficie != 0 )
                                {
                                    moyenneR = totalR / superficie ;
                                    moyenneG = totalG / superficie ;
                                    moyenneB = totalB / superficie ;
                                }
                                previousSuperficie = superficie ;
                            }
                            else
                            {
                                // calcul pour les pixels suivants :
                                // on calcule le total pour la dernière ligne
                                // et on rajoute la superficie
                                // on calcule le total pour la premiere ligne
                                // et on retire la superficie
                                for ( int t = i-scope ; t <= i+scope ; t++ )
                                {
                                    int u =  j+scope ;
                                    {
                                        if ( t > 0 && t < maxX && u > 0 && u < maxY )
                                        {
                                            pixel = getpixel(gScreenSurface,t,u);
                                            previousSuperficie++ ;

                                            totalR += (( pixel >>( shifta ) ) & 0xFF ) ;
                                            totalG += (( pixel >>( shiftb ) ) & 0xFF ) ;
                                            totalB += ((pixel >>( shiftc ) ) & 0xFF ) ;
                                        }
                                    }

                                    u = j-scope-1 ;
                                    {
                                        if ( t > 0 && t < maxX && u > 0 && u < maxY )
                                        {
                                            pixel = getpixel(gScreenSurface,t,u);
                                            previousSuperficie-- ;

                                            totalR -= (( pixel >>( shifta )) & 0xFF ) ;
                                            totalG -= (( pixel >> ( shiftb ) ) & 0xFF ) ;
                                            totalB -= ((pixel >> ( shiftc ) ) & 0xFF ) ;
                                        }
                                    }
                                }

                                if ( previousSuperficie != 0 )
                                {
                                    moyenneR = totalR / previousSuperficie ;
                                    moyenneG = totalG / previousSuperficie ;
                                    moyenneB = totalB / previousSuperficie ;
                                }
                            }


                            if ( i < maxX && j < maxY && i > 0 && j > 0 )
                            {
                                putpixel(gScreenSurface,i,j,(moyenneR <<( shifta ))+(moyenneG <<( shiftb ))+(moyenneB <<(shiftc ) ) );
                            }
                        }
                    }

                    SDL_UpdateWindowSurface( gWindow );
                }


                if ( page == '1' )
                    {

                        int spacing = 65 ;
                        int initialX = 400 ;
                        int initialY = 400 ;

                        std::ifstream is ( "bible.txt", std::ifstream::binary);
                        if ( is )
                        {
                            is.seekg(0,is.end);
                            long length = is.tellg();
                            is.seekg(0,is.beg);

                            char * buffer = new char [35];

                            long position = ( rand()%(length/0xFFFF) ) * 0xFFFF + rand() ; // il faut créer un nombre à la hauteur

                            is.seekg(position);
                            is.read(buffer,35);

                            couleurNoire = {rand()%(0xFF+1), rand()%(0xFF+1), rand()%(0xFF+1)};
                        // string colornames = to_string(killR) + " " + to_string(killG) + " " + to_string( killB);
                        // texte = TTF_RenderText_Blended(police, colornames.c_str(), couleurNoire);

                        int index = 0 ;
                        int chew = 0 ;

                        while ( index < 34 )
                        {

                        chew = ( rand()%8 + 1 ) ;
while ( index + chew > 35 ) { chew-- ; }
                         cout << "index=" << index << " chew= " << chew << endl ;

                        char * bufferMini = new char[10];

                        for ( int i = 0 ; i < chew ; i++ )
                        {
                            bufferMini[i] = buffer[index+i];
                        }
                        bufferMini[chew] = 0 ;

                        cout << bufferMini << endl ;

                        texte = TTF_RenderText_Blended(police, bufferMini, couleurNoire);
                        positionimpact.x = initialX ;
                        positionimpact.y = initialY ;
                        SDL_BlitSurface(texte, NULL, gScreenSurface, &positionimpact); /* Blit du texte */

                        initialX = initialX + ( rand() % chew ) * spacing / 2 ;
                        initialY = initialY + spacing ;
                        index += chew ;
                        }

                        SDL_UpdateWindowSurface( gWindow );



                        }

                        is.close();
                    }


                    if ( page == '2' )    // RICHTER NEW YEAR
                    {
                        int x = rand()% ( maxX - 1 ) /2  ;
                        int y = rand()% ( maxY - 1 ) /2 ;

                        int taille = rand()%(maxX - x) ;

                        UINT32 pixel ;

                        while ( x+taille >= maxX )
                        {
                            taille -- ;
                        }

                        // composition du tableau d'abord

                        int hauteurTotale[taille] = {0};

                        int part = taille / 2 ;

                        while ( part > 2 )

                        {
                            part = part / 2 ;
                            cout << "part=" << part << endl ;

                            for ( int j = 0 ; j < ( taille / part ) ; j++ )
                            {


                                   UINT32 hauteur = rand()% part ;
                                   cout << "hauteur=" << hauteur << endl ;

                            for ( int k = j * part ; k < ((j+1) * part ) ; k++ )
                            {
                                hauteurTotale[k] += hauteur ;
                            }

                            }
                        }

                        for (int i = 0 ; i < taille ; i ++)
                        {


                            while ( (y + hauteurTotale[i]) >= (maxY-1) )
                            {
                                hauteurTotale[i]-- ;
                            }

                             if ( hauteurTotale[i] <= 0 )
                            {
                                hauteurTotale[i] = 1 ;
                            }
                        }

                        cout << "table finished" << endl ;

                        for (int i = x ; i <   (x+taille) % (maxX - 1) ; i++ )
                        {
                            cout << i << " " ;

                            Uint32 moyenneR  =0 ;
                            Uint32 moyenneG  = 0;
                            Uint32 moyenneB   =0 ;
                            Uint32 totalR  = 0 ;
                            Uint32 totalG  = 0;
                            Uint32 totalB   = 0 ;

Uint32 initPixel = 0 ;

                            pixel = getpixel(gScreenSurface,i,y);
initPixel = pixel ;
initPixel = initPixel & 0xFFFFFF ;

                            for (int j = y ; j <   (y+ hauteurTotale[i]) % (maxY-1) ; j++ )
                            {




                                pixel = getpixel(gScreenSurface,i,j);
                                totalR += (( pixel >>16 ) & 0xFF ) ;
                                totalG += (( pixel >>8 ) & 0xFF ) ;
                                totalB += ((pixel >>0 ) & 0xFF ) ;

                            }
// cout << "x";

Uint32 color2  = 0 ;

if ( hauteurTotale[i] != 0 )
{


                            moyenneR = totalR / (Uint32) (hauteurTotale[i] )  ;
                            moyenneG = totalG / (Uint32) (hauteurTotale[i] )  ;
                            moyenneB = totalB / (Uint32) (hauteurTotale[i] )  ;

                             color2 = ( moyenneR << 16) + (moyenneG << 8 ) + moyenneB ;
}
else
{
    cout << "hauteur nulle " << i << endl ;
    cout << "taille" << taille ;
}

                            for (int  j = y ; j <   ( y + hauteurTotale[i] ) % (maxY-1)  ; j++ )
                            {
                               // cout << "1"   ;
                                Uint32 intermed = intermediateColor(initPixel,color2,(float)(((j-y)*100)/(hauteurTotale[i]+1)  ));
//cout << "2";
                                putpixel(gScreenSurface,i,j,intermed );
//cout << "3";
                            }
                           // cout << ".";

                        }
                        SDL_UpdateWindowSurface( gWindow );

                    }




                    if ( page == '3' )    // PUZZLE 2022
                    {

                    }


                       if ( page == '4' )    // PUZZLE NON COMPLETE
                    {

                    }

                  if ( page == '5' )    // BLACK WHITE
                    {
                        UINT32 pixel ;

                        int threshold = rand()%255 ;
int choice = rand()%3 ;

                        for ( int i = 0 ; i < SCREEN_WIDTH ; i++ )
                        {
                            for ( int j = 0 ; j < SCREEN_HEIGHT ; j++ )
                            {
                            pixel = getpixel(gScreenSurface,i,j);


                                  int           totalR = (( pixel >>16 ) & 0xFF ) ;
                              int  totalG = (( pixel >>8 ) & 0xFF ) ;
                           int     totalB = ((pixel >>0 ) & 0xFF ) ;

if ( choice == 0 )
{

                            if (totalR < threshold ) { pixel = 0  ; } else { pixel = 0xFFFFFF ; }
}

if ( choice == 1 )
{

                            if (totalG < threshold ) { pixel = 0  ; } else { pixel = 0xFFFFFF ; }
}

if ( choice == 2 )
{

                            if (totalB < threshold ) { pixel = 0  ; } else { pixel = 0xFFFFFF ; }
}

if ( choice == 3 )
{

                            if (totalB < threshold  && totalR < threshold && totalG << threshold) { pixel = 0  ; } else { pixel = 0xFFFFFF ; }
}


if ( choice == 4 )
{

                            if (totalB < threshold  && totalR < threshold && totalG << threshold) { pixel = 0xFFFFFF  ; } else { pixel = 0 ; }
}


                                putpixel(gScreenSurface,i,j,pixel );

                            }
                        }


                        SDL_UpdateWindowSurface( gWindow );

                    }







                }
                break ;


                case SDLK_o: // Appui sur la touche o, on agrandit une partie de l'écran
                {
                    mode = 'o' ;
                    if ( page == '0' )
                    {
                        {
                            int x =  rand()% maxX + 1 ;
                            int y =  rand()% maxY +1  ;
                            int w = rand() % ( maxX - x ) + 1 ;
                            int h = rand() % ( maxX - y ) + 1 ;
                            int newx =  rand()% maxX + 1 ;
                            int newy =  rand()% maxY +1  ;


                            for ( int k = 0 ; k < w  ; k++)
                            {
                                for ( int m = 0 ; m < h ; m++)
                                {
                                    Uint32 pixel  = getpixel(gScreenSurface,(x+k*2)%maxX, (y+m*2)%maxY) ;
                                    Uint32 newPixel = pixel  ;

                                    int cornerX = newx + k*expand ;
                                    int cornerY = newy + m*expand ;

                                    if ( rand()%16 < fillPixel )
                                    {
                                        for ( int n = 0 ; n < expand ; n++)
                                        {
                                            for ( int o = 0 ; o < expand ; o++)
                                            {
                                                //  putpixel(gScreenSurface,(newx+k*n)%maxX,(newy+m*n)%maxY, newPixel  );


                                                putpixel(gScreenSurface,(cornerX+n)%maxX,(cornerY+o)%maxY, newPixel  );
                                            }
                                        }


                                    }
                                }
                            }
                        }
                        SDL_UpdateWindowSurface( gWindow );
                        SDL_Delay(delayExpand);
                    }

                    if (page == '1')
                    {
                        string display = "REPLICATE"   ;
//                       stringToConvert(display);
                        couleurNoire = {220, 220, 220};
                        texte = TTF_RenderText_Blended(police, display.c_str(), couleurNoire);
                        positionimpact.x = 40 ;;
                        positionimpact.y = 20 ;;
                        SDL_BlitSurface(texte, NULL, gScreenSurface, &positionimpact); /* Blit du texte */
                        SDL_UpdateWindowSurface( gWindow );

                        {
                            int x =  rand()% 800 + 1 ;
                            int y =  rand()% 600+1  ;
                            int w = rand() % ( 800 - x ) + 400 ;
                            int h = rand() % ( 600 - y ) + 500 ;
                            int newx =  rand()% 800+ 1 ;
                            int newy =  rand()% 600 +1  ;

                            for ( int k = 0 ; k < w  ; k++)
                            {
                                for ( int m = 0 ; m < h ; m++)
                                {
                                    Uint32 pixel  = getpixel(gScreenSurface,(x+k)%maxX, (y+m)%maxY) ;
                                    Uint32 newPixel = pixel  ;

                                    int cornerX = newx ;
                                    int cornerY = newy ;

                                    Uint32 killR = (( pixel >>( 16 ) ) & 0xFF ) / ( 256 / sizeColorPick )  ;
                                    Uint32 killG = (( pixel >>( 8 ) )  & 0xFF ) / ( 256 /sizeColorPick) ;
                                    Uint32 killB = (( pixel >>( 0 ) )  & 0xFF ) / ( 256 /sizeColorPick ) ;

                                    if ( colorPick[killR][killG][killB] == 0 )
                                    {
                                        putpixel(gScreenSurface,(cornerX+k)%maxX,(cornerY+m)%maxY, newPixel  );

                                    }
                                }
                            }
                        }
                        SDL_UpdateWindowSurface( gWindow );

                        SDL_Delay(10 );
                    }

                    if (page == '2')
                    {
                        {
                            int x =  rand()% maxX + 1 ;
                            int y =  rand()% maxY +1  ;
                            int w = rand() % ( maxX - x ) + 1 ;
                            int h = rand() % ( maxX - y ) + 1 ;
                            int newx =  rand()% maxX + 1 ;
                            int newy =  rand()% maxY +1  ;

                            for ( int k = 0 ; k < w  ; k++)
                            {
                                for ( int m = 0 ; m < h ; m++)
                                {
                                    Uint32 pixel  = getpixel(gScreenSurface,(x+k*2)%maxX, (y+m*2)%maxY) ;
                                    Uint32 newPixel = pixel  ;

                                    int cornerX = newx + k*10;
                                    int cornerY = newy + m*10;

                                    // if ( rand()%16 < fillPixel )
                                    {
                                        for ( int n = 0 ; n < 20 ; n++)
                                        {
                                            for ( int o = 0 ; o < 20 ; o++)
                                            {
                                                //  putpixel(gScreenSurface,(newx+k*n)%maxX,(newy+m*n)%maxY, newPixel  );


                                                putpixel(gScreenSurface,(cornerX+n)%maxX,(cornerY+o)%maxY, newPixel  );
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        SDL_UpdateWindowSurface( gWindow );
                        SDL_Delay(100);
                    }


                    if ( page == '3')
                    {
                        // SELECT RANGE 2021
                        // ON CLICK !
                    }

   if ( page == '4')
                    {
                        // CLEAVAGE 2021
                        // ON CLICK !
                    }

                      if ( page == '5')
                    {
                        // DIFFERNTIAL 2021
                        // ON CLICK !
                    }



                }
                break;

                case SDLK_p: // Appui sur la touche p, on sauve
                {
                    mode = 'p' ;
                    if ( page == '0' )
                    {
                        string A = "uQitll_" ;

                        A += (char) (rand()%26 + 'a') ;
                        A += (char) (rand()%26 + 'a') ;
                        A += (char) (rand()%26 + 'a') ;
                        A += to_string(rand()%10000);
                        A += ".bmp";
                        stringToConvert(A);

                        SDL_SaveBMP(gScreenSurface, convert ) ;
                        rememberNumber++ ;
                        SDL_Delay(100);
                    }

                    if ( page == '2' )
                    {
                        string A = "wv_uQitll_" ;

                        A += (char) (rand()%26 + 'a') ;
                        A += (char) (rand()%26 + 'a') ;
                        A += (char) (rand()%26 + 'a') ;
                        A += to_string(rand()%10000);
                        A += ".wav";

                        saveWAVcomplete ( A ) ;

                        string display = "SAVED WAV"   ;

                        //  stringToConvert(display);
                        couleurNoire = {220, 220, 220};
                        texte = TTF_RenderText_Blended(police, display.c_str(), couleurNoire);
                        positionimpact.x = 40 ;;
                        positionimpact.y = 20 ;;
                        SDL_BlitSurface(texte, NULL, gScreenSurface, &positionimpact); /* Blit du texte */


                        SDL_Delay(100);
                    }
                    SDL_UpdateWindowSurface( gWindow );
                }
                break;


                case SDLK_r: // Appui sur la touche r, on réduit
                {
                    mode = 'r' ;
                    if ( page == '0' )
                    {


                        int x =  rand()% maxX + 1 ;
                        int y =  rand()% maxY +1  ;
                        int w = rand() % ( maxX - x ) ;
                        w = 100 ;
                        int h = rand() % ( maxX - y ) ;
                        h = 100 ;

                        for ( int k = 0 ; k < w  ; k++)
                        {
                            for ( int m = 0 ; m < h  ; m++)
                            {
                                Uint32 pixel  = getpixel(gScreenSurface,(x+k*2)%maxX, (y+m*2)%maxY) ;



                                Uint32 newPixel = rand()%0xFF << 16 + rand()%0xFF << 8 + rand()%0xFF << 0 ;
                                newPixel = pixel  ;

                                putpixel(gScreenSurface,(x+w+k)%maxX,(y+h+m)%maxY, newPixel  );


                                /*
                                pixel2 = getpixel(gScreenSurface, x+i*2+1, y+j*2);
                                pixel3 = getpixel(gScreenSurface, x+i*2, y+j*2+1);
                                pixel4 = getpixel(gScreenSurface, x+i*2+1, y+j*2+1);

                                Uint8 meanR = (pixel1>>16)& 0xFF + (pixel2>>16)&  0xFF + (pixel3>>16) & 0xFF + (pixel4>>16)&  0xFF ;
                                meanR /=4 ;
                                Uint8 meanG = (pixel1>>8)& 0xFF + (pixel2>>8) & 0xFF + (pixel3>>8)&  0xFF + (pixel4>>8)&  0xFF ;
                                meanG /=4 ;
                                Uint8 meanB = (pixel1>>0)& 0xFF + (pixel2>>0) & 0xFF + (pixel3>>0)&  0xFF + (pixel4>>0)&  0xFF ;
                                meanB /=4 ;

                                Uint32 pixel = (meanR<<16)+(meanG<<8)+(meanB) ;


                                if ( x+i > 0 && x+i < maxX  && y+j > 0 && y+j < maxY   )
                                {
                                   // putpixel(gScreenSurface,rand()%maxX,rand()%maxY,rand()%0xFF << 16 + rand()%0xFF << 8 + rand()%0xFF << 0);
                                      putpixel(gScreenSurface,(x+i)%maxX, (y+j)%maxY , pixel1 );
                                                              //  putpixel(gScreenSurface, (x+i)%maxX, (y+j)%maxY,pixel );
                                }
                                */

                            }
                        }
                        SDL_UpdateWindowSurface( gWindow );
                    }

                    if ( page == '1' )
                    {
                        int x =  rand()% maxX + 1 ;
                        int y =  rand()% maxY +1  ;
                        int w = rand() % ( maxX - x ) + 1 ;
                        w = w % ( maxY - y ) + 1 ;
                        int newx =  rand()% maxX + 1 ;
                        int newy =  rand()% maxY +1  ;
                        int newI, newJ ;

                        for ( int i = 0 ; i < w ; i++ )
                        {
                            for ( int j = 0 ; j < w ; j++ )
                            {
                                // copier pixel
                                {
                                    if ( i <= w/2 && j <= w/2 )
                                    {
                                        newI = w+(w-j);
                                        newJ = i ;
                                    }

                                    if ( i >= w/2 && j <= w/2 )
                                    {
                                        newI = w+(w-j);
                                        newJ = i ;
                                    }

                                    if ( i >= w/2 && j >= w/2 )
                                    {
                                        newI = w+(w-j);
                                        newJ = i ;
                                    }

                                    if ( i <= w/2 && j >= w/2 )
                                    {
                                        newI = w+(w-j);
                                        newJ = i ;
                                    }


                                    Uint32 pixel  = getpixel(gScreenSurface,(x+i)%maxX, (y+j)%maxY) ;
                                    Uint32 newPixel = pixel  ;
                                    putpixel(gScreenSurface,(newx+newI)%maxX,(newy+newJ)%maxY, newPixel  );
                                }

                            }

                        }

                        SDL_UpdateWindowSurface( gWindow );
                        SDL_Delay(100);

                    }

                }
                break;


                case SDLK_s: // Appui sur la touche s, on passe en mode taille
                {

                    mode = 's' ;
                    if ( page == '0' )
                    {
                        mode = 's' ;
                        newMode = "s" ;
                    }

                    if ( page == '1' )
                    {
                        autoSave = !autoSave ;


                        string display = "autoSave "   ;
                        if (autoSave == true )
                        {
                            display += " ON" ;
                        }
                        else
                        {
                            display  += " OFF" ;
                        }
                        cout << display ;

                        // stringToConvert(display);
                        couleurNoire = {120, 120, 120};
                        texte = TTF_RenderText_Blended(police, display.c_str(), couleurNoire);
                        cout << "TTF";
                        positionimpact.x = 40 ;;
                        positionimpact.y = 20 ;;

                        SDL_BlitSurface(texte, NULL, gScreenSurface, &positionimpact); /* Blit du texte */
                        cout << "blit" ;
                        SDL_UpdateWindowSurface( gWindow );
                        cout << "update" ;

                        SDL_Delay(400);
                    }


                    if ( page == '2' )
                    {
                        mode = 's';
                        newMode = "s2" ;
                        minimumH = 0 ;
                        minimumW = 0 ;
                    }

                }
                break;

                case SDLK_t: // Appui sur la touche t, on passe en mode transparence
                    mode = 't' ;
                    break;

                case SDLK_u: // Appui sur la touche u, on dessine des cibles
                {
                    mode = 'u' ;
                    int x = rand()% maxX / 2 ;
                    int y = rand()% maxY / 2 ;
                    int taille = rand()%50 ;

                    for (int i = 0 ; i < 8 ; i++ )

                    {
                        int x1 = x + basicW * i ;
                        for (int j = 0 ; j < 8 ; j++ )
                        {
                            int y1 = y + basicH * j ;

                            for ( int t = x1 - taille ; t < x1 + taille  ; t++ )
                            {
                                if ( t < maxX && y1 < maxY && t > 0 && y1 > 0 )
                                    putpixel(gScreenSurface,t,y1,0xFFFFFFFF);
                            }

                            for ( int t = y1 - taille ; t < y1 + taille ; t++ )
                            {
                                if ( x1 < maxX && t < maxY && x1 > 0 && t > 0 )
                                    putpixel(gScreenSurface,x1,t,0xFFFFFFFF);
                            }
                        }
                    }

                    SDL_UpdateWindowSurface( gWindow );
                }

                break;

                case SDLK_v: // Appui sur la touche v, on passe en mode vitesse
                    mode = 'v' ;
                    attente = 1 ;
                    break;

                case SDLK_w: // Appui sur la touche w, on passe en mode fix spacing
                    mode = 'w' ;
                    fixSpacingx= 1 ;
                    fixSpacingy = 1 ;
                    break;

                case SDLK_x: // Appui sur la touche x, on initialise la transparence à nulle
                    mode = 'x' ;
                    valeurBaseTransparence = 0 ;
                    variationTransparence = 1 ;
                    break;

                case SDLK_y: // Appui sur la touche y, on initialise la transparence à maximale
                    mode = 'y' ;
                    valeurBaseTransparence = 255 ;
                    variationTransparence = 1 ;
                    break;

                case SDLK_UP: // Flèche haut
                    valeurBaseTransparence++ ;
                    break;
                case SDLK_DOWN: // Flèche bas
                    valeurBaseTransparence-- ;
                    break;
                case SDLK_RIGHT: // Flèche droite
                    variationTransparence ++;
                    break;
                case SDLK_LEFT: // Flèche gauche
                    variationTransparence --;
                    break;
                }
            }
            break ;

            case SDL_MOUSEBUTTONUP:
            {
                if ( mode == 's')
                {
                    if ( newMode == "s" )
                    {


                        basicW = event.button.x;
                        basicH = event.button.y;
                    }


                    if ( newMode == "s2")
                    {
                        minimumW = event.button.x;
                        minimumH = event.button.y;
                    }
                }

                if ( mode == 'a' && page == '1' )
                {
                    variationX = event.button.x;
                    variationY = event.button.y;
                }

                if ( mode == 'a' && page == '5')  // blow UP detail
                {

                    int x = event.button.x ;
                    int y = event.button.y ;

                    // on doit copier l'image dans un double

                    // pour ensuite appliquer le blowUP sur gScreenSurface
                    // la surface à agrandir est sx1, sy1, sx2, sy2

                    int sx1 = x - blowUpSelectaX /2 ;
                    if ( sx1 < 0 )
                    {
                        sx1 = 0 ;
                    }

                    int sy1 = y - blowUpSelectaY /2;
                    if ( sy1 < 0 )
                    {
                        sy1 = 0 ;
                    }


                    int sx2 = x + blowUpSelectaX /2;
                    if ( sx2 >= SCREEN_WIDTH )
                    {
                        sx2 = SCREEN_WIDTH -1 ;
                    }

                    int sy2 = y + blowUpSelectaY /2;
                    if ( sy2 >= SCREEN_HEIGHT )
                    {
                        sy2 = SCREEN_HEIGHT - 1 ;
                    }

                    // on a déterminé la zone qui va être zoomée
                    // on calcule maintenant le ratio entre cette zone et la taille de l'écran

                    int wx = sx2 - sx1 ;
                    int wy = sy2 - sy1 ;

                    while ( sx1 + wx > SCREEN_WIDTH ) { wx-- ; };
                    while ( sy1 + wy > SCREEN_HEIGHT ) { wy-- ; };

                    cout << "wx = " << wx << " and wy = " << wy << endl ;

                    float ratioX = (float) SCREEN_WIDTH / (float)  wx    ;
                    float ratioY = (float) SCREEN_HEIGHT / (float)  wy    ;

                    cout << "ratio x " << ratioX << " and ratio y = " << ratioY << endl ;

                    Uint32 screenCopyTable[wx][wy] = {0};

                    for ( int k = 0 ; k < wx ; k++ )
                    {
                        for (int m = 0 ; m < wy ; m++ )
                        {
                            screenCopyTable[k][m] = getpixel(gScreenSurface, sx1+ k, sy1 + m ) ;
                        }
                    }

                    cout << "copied int table ";


                    for ( int k = 0 ; k < SCREEN_WIDTH  ; k++)
                    {
                        //  cout << k ;
                        for ( int m = 0 ; m < SCREEN_HEIGHT ; m++)
                        {
                            // cout << "putting " << k << "-" << m << endl ;
                            int item1 = (int) ( (float) k / (float) ratioX ) ;
                            int item2 = (int) ( (float) m / (float) ratioY  ) ;
                            // putpixel(gScreenSurface, k, m, screenCopyTable[k/ratioX][m/ratioY] );
                            putpixel(gScreenSurface, k, m, screenCopyTable[item1][item2] );
                            // cout << "put";

                        }
                        cout << "." ;
                    }

                    SDL_UpdateWindowSurface( gWindow );
                }

                if ( mode == 'a' && page == '6' )
                {
                    points temporaire ;
                    temporaire.x = event.button.x ;
                    temporaire.y = event.button.y ;

                    zonePoints.push_back(temporaire);

                    int nbZones = zonePoints.size() / 2 ;
                    SDL_UpdateWindowSurface( gWindow );

                    cout << "i sense " << nbZones << " zones " ;

                    if (nbZones >= 1)
                    {

                        for ( int i = 0 ; i < nbZones ; i++ )
                        {
                            // prévoir un switch des points si ils sont mal rangés !
                            // TODO

                            int a = zonePoints[i*2].x ;
                            int b = zonePoints[i*2].y ;
                            int c = zonePoints[i*2+1].x ;
                            int d = zonePoints[i*2+1].y ;

                            if ( a > c && b > d )
                            {
                                zonePoints[i*2].x = c ;
                                zonePoints[i*2].y = d ;
                                zonePoints[i*2+1].x = a ;
                                zonePoints[i*2+1].y = b ;
                            }

                            if ( a > c && b < d )
                            {
                                zonePoints[i*2].x = c ;
                                zonePoints[i*2].y = b ;
                                zonePoints[i*2+1].x = a ;
                                zonePoints[i*2+1].y = d ;
                            }

                            if ( a < c && b > d )
                            {
                                zonePoints[i*2].x = a ;
                                zonePoints[i*2].y = d ;
                                zonePoints[i*2+1].x = c ;
                                zonePoints[i*2+1].y = b ;
                            }


                            cout << "-------"<< endl ;
                            cout << zonePoints[i*2].x << "-" << zonePoints[i*2].y << " " << zonePoints[i*2+1].x << "-" << zonePoints[i*2+1].y << endl ;
                            ownOutline(gScreenSurface, zonePoints[i*2].x, zonePoints[i*2].y, zonePoints[i*2+1].x, zonePoints[i*2+1].y,
                                       0xFFFFFF
                                      );

                        }
                    }
                    SDL_UpdateWindowSurface( gWindow );

                    cout << endl ;
                    cout << "**************" ;

                    cout << endl ;
                    SDL_Delay(100);
                }



                if ( mode == 'd' && page == '0')
                {


                    pragmaticalMaxX = event.button.x;
                    pragmaticalMaxY = event.button.y;
                }


                if ( mode == 'd' && page == '5')
                {
                    blowUpSelectaX = event.button.x;
                    blowUpSelectaY = event.button.y;
                }

                if ( mode == 'e')
                {
                    freqSymetries = event.button.x % 100 ;
                    freqDuplicates = event.button.y % 500 ;
                }


                if ( mode == 'f')
                {
                    if ( page == '0')
                    {
                        nextImage = event.button.x;
                        nextImageVariation = event.button.y;
                        if ( nextImageVariation <= 0 )
                        {
                            nextImageVariation = 1 ;
                        }
                    }

                    if ( page == '1')
                    {
                        int x  = event.button.x;
                        int y  = event.button.y;
                        Uint32  pixel = getpixel(gScreenSurface,x,y);

                        Uint32 killR = (( pixel >>( 16 ) ) & 0xFF ) / ( 256 / sizeColorPick ) ;
                        Uint32 killG = (( pixel >>( 8 ) )  & 0xFF ) / ( 256 / sizeColorPick ) ;
                        Uint32 killB = ((pixel >>( 0 ) )  & 0xFF ) / ( 256 / sizeColorPick )  ;
                        colorPick[killR][killG][killB] = 0 ;
                    }
                }


                if ( mode == 'g')
                {
                    if ( page == '0')
                    {

                        int x  = event.button.x;
                        int y  = event.button.y;
                        Uint32  pixel = getpixel(gScreenSurface,x,y);


                        transpaR = (( pixel >>( 16 ) ) & 0xFF ) ;
                        transpaG = (( pixel >>( 8 ) ) & 0xFF ) ;
                        transpaB = (( pixel >>( 0 ) ) & 0xFF ) ;

                        // TODO DEBUG TY5
                        //   SDL_SetColorKey(impact, SDL_SRCCOLORKEY, SDL_MapRGB(impact->format, transpaR, transpaG, transpaB));
                    }

                    if ( page == '1')
                    {
                        // on va choisir une couleur
                        // déterminer à quelle case du cube de couleurs elle appartient
                        // cette valeur devient 1
                        // on va trouver une touche qui applique homothétie d'ecran avec ces couleurs en moins

                        int x  = event.button.x;
                        int y  = event.button.y;
                        Uint32  pixel = getpixel(gScreenSurface,x,y);

                        Uint32 killR = (( pixel >>( 16 ) ) & 0xFF ) / ( 256 / sizeColorPick ) ;
                        Uint32 killG = (( pixel >>( 8 ) )  & 0xFF ) / ( 256 / sizeColorPick ) ;
                        Uint32 killB = (( pixel >>( 0 ) )  & 0xFF ) / ( 256 / sizeColorPick )  ;
                        colorPick[killR][killG][killB] = 1 ;
                    }


                }

                if ( mode == 'm')
                {
                    if ( page == '9')
                    {
                         int x  = event.button.x;
                        int y  = event.button.y;
                        Uint32  pixel = getpixel(gScreenSurface,x,y);

                        Uint32 killR = (( pixel >>( 16 ) ) & 0xFF )   ;
                        Uint32 killG = (( pixel >>( 8 ) )  & 0xFF )   ;
                        Uint32 killB = (( pixel >>( 0 ) )  & 0xFF )    ;


                        for  (int i = 390 ; i < 900 ; i++  )
{
    for ( int j = 200 ; j < 300 ; j++ )
    {
                             putpixel(gScreenSurface, i,j,0xFFFFFF) ;

    }
}
                        couleurNoire = {0, 0, 0};
                        string colornames = to_string(killR) + " " + to_string(killG) + " " + to_string( killB);
                        texte = TTF_RenderText_Blended(police, colornames.c_str(), couleurNoire);
                        positionimpact.x = 400 ;;
                        positionimpact.y = 200 ;;
                        SDL_BlitSurface(texte, NULL, gScreenSurface, &positionimpact); /* Blit du texte */
                        SDL_UpdateWindowSurface( gWindow );

                    }
                }



                 if ( mode == 'n')
                {
                    if ( page == '3')
                    {
                        int x  = event.button.x;
                        int y  = event.button.y;

                        int reachX = (maxX / x) - 1 ;  while ( reachX < 0) { reachX++ ; }
                        int reachY= (maxY / y) - 1 ;  while ( reachY < 0) { reachY++ ; }

                                               Uint32  pixel  ;

                        for ( int i = 0 ; i <= reachX ; i++)
                        {
                            for ( int j = 0 ; j <= reachY ; j++)
                            {
                                for ( int t = 0 ; t < x ; t++ )
                                {
                                    for ( int u = 0 ; u < y ; u++ )
                                    {
                                        pixel = getpixel(gScreenSurface,i*x+t,j*y+u);
                                        image[((reachX-i)*x)+t][((reachY-j)*y)+u]= pixel ;
                                    }
                                }
                            }
                        }

                        for ( int i = 0 ; i < maxX ; i++ )
                        {
                            for ( int j = 0 ; j < maxY ; j++)
                            {
                               putpixel(gScreenSurface, i, j, image[i][j] );
                            }
                        }


                        SDL_UpdateWindowSurface( gWindow );

                    }


                if ( page == '4')
                    {
                        int x  = event.button.x;
                        int y  = event.button.y;

                        int reachX = (maxX / x) - 1 ;  while ( reachX < 0) { reachX++ ; }
                        int reachY= (maxY / y) - 1 ;  while ( reachY < 0) { reachY++ ; }

                                               Uint32  pixel  ;

                         for ( int i = 0 ; i < maxX ; i++ )
                        {
                            for ( int j = 0 ; j < maxY ; j++)
                            {
                              pixel = getpixel(gScreenSurface,i ,j );
                                        image[i][j]= pixel ;
                            }
                        }

                        for ( int i = 0 ; i <= reachX ; i++)
                        {
                            for ( int j = 0 ; j <= reachY ; j++)
                            {
                                int targetI = rand()%(reachX+1) ;
                                int targetJ = rand()%(reachY+1) ;

                                for ( int t = 0 ; t < x ; t++ )
                                {
                                    for ( int u = 0 ; u < y ; u++ )
                                    {
                                        pixel = getpixel(gScreenSurface,i*x+t,j*y+u);
                                        image[((reachX-targetI)*x)+t][((reachY-targetJ)*y)+u]= pixel ;
                                    }
                                }
                            }
                        }

                        for ( int i = 0 ; i < maxX ; i++ )
                        {
                            for ( int j = 0 ; j < maxY ; j++)
                            {
                               putpixel(gScreenSurface, i, j, image[i][j] );
                            }
                        }


                        SDL_UpdateWindowSurface( gWindow );

                    }



                }



                if ( mode == 'o')
                {
                    if ( page == '1')
                    {
                        expand = event.button.x / 100 ;
                        fillPixel = event.button.y % 16 + 1 ;
                        // delayExpand = event.button.y / 100 ;
                    }

                    if ( page == '3')
                    {
                        // SELECT

                        int x  = event.button.x;
                        int y  = event.button.y;
                        Uint32  pixel = getpixel(gScreenSurface,x,y);

                        clearMasque();

                        chosenR = (( pixel >>( 16 ) ) & 0xFF ) ;
                        chosenG = (( pixel >>( 8 ) )  & 0xFF );
                        chosenB = (( pixel >>( 0 ) )  & 0xFF );

                        cout << endl << "chosen " << chosenR << " " << chosenG << " " << chosenB << endl ;

                        range = 30 ;

                        selectMasque(x,y);

                        cout << "selected" ;

                        paintMasque(100,0,100,0);

                        SDL_UpdateWindowSurface( gWindow );
                    }


                    if ( page == '4')
                    {
                        // CLEAVAGE

                        int x  = event.button.x;
                        int y  = event.button.y;
                        Uint32  pixel = getpixel(gScreenSurface,x,y);

                                  chosenR = (( pixel >>( 16 ) ) & 0xFF ) ;
                        chosenG = (( pixel >>( 8 ) )  & 0xFF );
                        chosenB = (( pixel >>( 0 ) )  & 0xFF );


                        for ( int i = 10 ; i < SCREEN_WIDTH ; i = i + 30 )
                        {
                            for ( int j = 10 ; j < SCREEN_HEIGHT ; j = j + 30 )
                            {
                                 clearMasque();

                        range = 20 ;

                       cleavageMasque(i,j,0) ;

                        paintMasqueRegular(0,0, 0,0);



                            }
                        }
            SDL_UpdateWindowSurface( gWindow );
                    }

                    if ( page == '5')
                    {
                        // GRIBOUILLIS 2

                        int x  = event.button.x;
                        int y  = event.button.y;
                        Uint32  pixel = getpixel(gScreenSurface,x,y);

                                  chosenR = (( pixel >>( 16 ) ) & 0xFF ) ;
                        chosenG = (( pixel >>( 8 ) )  & 0xFF );
                        chosenB = (( pixel >>( 0 ) )  & 0xFF );

                        clearMasque();
                        range = 30 ;

  //                       cleavageMasque2(x,y,0) ;

    //                    paintMasqueRegular(0,0, 0,0);

// SDL_UpdateWindowSurface( gWindow );


                        for ( int i = 10 ; i < SCREEN_WIDTH ; i = i + 30 )
                        {
                            for ( int j = 10 ; j < SCREEN_HEIGHT ; j = j + 30 )
                            {
                       cleavageMasque2(i,j,0) ;

                        paintMasqueRegular(0,0, 0,0);



                            }
                        }
 SDL_UpdateWindowSurface( gWindow );
                    }

  if ( page == '6')
                    {
                        // DIFFERENTIAL

                        int x  = event.button.x;
                        int y  = event.button.y;
                        Uint32  pixel = getpixel(gScreenSurface,x,y);

                        clearMasque();

                        selectMasqueDifferential(x,y);

                        cout << "selected" ;

                        paintMasque(100,0,100,0);

                        SDL_UpdateWindowSurface( gWindow );
                    }

                      if ( page == '7')
                    {
                        // DIFFERENTIAL TOTAL

                        // int x  = event.button.x;
                        // int y  = event.button.y;

                        clearMasque();

                        for ( int i = 10 ; i < SCREEN_WIDTH - 10 ; i++ )
                        {
                            for ( int j = 10 ; j < SCREEN_HEIGHT - 10 ; j++ )
                            {
                                if ( rand() % 1000 == 0)
                                 selectMasqueDifferential(i,j);
                            }
                        }

                        paintMasque(100,0,100,0);

                        SDL_UpdateWindowSurface( gWindow );
                    }


                }




                if ( mode == 'v')
                {
                    attente = event.button.x * 10 ;

                }

                if ( mode == 't' )
                {
                    valeurBaseTransparence = ( event.button.x / 5 )% 255 ;
                    variationTransparence = ( event.button.y / 2 ) % 255 ;
                    if ( variationTransparence == 0 )
                    {
                        variationTransparence = 1 ;
                    }

                    string display = to_string(valeurBaseTransparence) + "+-" + to_string(variationTransparence) ;
                    stringToConvert(display);
                    couleurNoire = {0, 0, 0};
                    texte = TTF_RenderText_Blended(police, display.c_str(), couleurNoire);

                    positionimpact.x = 100 ;
                    positionimpact.y = 100 ;
                    SDL_BlitSurface(texte, NULL, gScreenSurface, &positionimpact); /* Blit du texte */

                    SDL_UpdateWindowSurface( gWindow );
                }

                if ( mode == 'w')
                {
                    fixSpacingx = event.button.x;
                    fixSpacingy = event.button.y;


                }



            }
            break;

            }



        }

        // cout << "." ;


        /*

                    if ( transpa )
                    {
                         // SDL_SetColorKey(impact, SDL_SRCCOLORKEY, SDL_MapRGB(impact->format, transpaR, transpaG, transpaB));
                    }

                    */





        if ( symetries == true && rand() % freqSymetries  == 0 )
        {
            switch ( rand() % 2 )
            {
            case 0 :
            {
                int x =  rand()% maxX ;
                int y =  rand()% maxY  ;

                x = x - ( x % fixSpacingx ) ;
                y = y - ( y % fixSpacingx ) ;

                int w = rand() % ( maxX - x ) ;
                int h = rand() % ( maxX - y ) ;

                for ( int i = -w ; i <= 0 ; i++ )
                {
                    for (int j = -h ; j <= +h ; j++)
                    {
                        if ( rand() % 500 <= freqDuplicates )
                            if ( x-i > 0 && x-i < maxX && x+i < maxX && x+i > 0 && y-j > 0 && y-j < maxY )
                            {
                                Uint32 pixel = getpixel(gScreenSurface,x-i,y-j) ;
                                putpixel(gScreenSurface, x+i,y-j, pixel ) ;
                            }
                        // on balance d'emblée la valeur qu'on prend, en 1 étape
                    }
                }

            }
            break ;

            case 1 :
            {
                int x =  rand()% maxX  ;
                int y =  rand()% maxY  ;

                x = x - ( x % fixSpacingx ) ;
                y = y - ( y % fixSpacingx ) ;

                int w = rand() % ( maxX - x ) ;
                int h = rand() % ( maxX - y ) ;

                for ( int i = -w ; i <= +w ; i++ )
                {
                    for (int j = -h ; j <= 0 ; j++)
                    {
                        //    if ( rand() % 50 < 45 )
                        if ( x-i > 0 && x-i < maxX  && y-j > 0 && y-j < maxY && y+j > 0 && y+j < maxY )
                        {
                            Uint32 pixel = getpixel(gScreenSurface,x-i,y-j) ;
                            putpixel(gScreenSurface, x-i,y+j, pixel ) ;
                        }
                        // on balance d'emblée la valeur qu'on prend, en 1 étape
                    }
                }

            }
            break ;
            }
        }


        ////////////////////////
        // PARTIE AUDIO touche 8
        ////////////////////////


        /*

        if ( rand() % 100 == 0 )
        {


            if ( rand() % 100 == 0 )
            {
                // C0waveformLength = 1000;
                buildSineWave(sineWave,C0waveformLength);
            }
            else
            {

// C0waveformLength = rand()%1000+ 100  ;

                buildPixelWave(sineWave, C0waveformLength);
            }
        }

        testVoiceA.waveform = sineWave;
     //   testVoiceB.waveform = sineWave;
     //   testVoiceC.waveform = sineWave;



        speak(&testVoiceA);
      //  speak(&testVoiceB);
     //   speak(&testVoiceC);

        if (audioMainAccumulator > 1)
        {
            for (i=0; i<samplesPerFrame; i++)
            {
                audioBuffer[audioMainLeftOff+i] /= audioMainAccumulator;
            }
        }
        audioMainAccumulator = 0;

        audioMainLeftOff += samplesPerFrame;
        if (audioMainLeftOff == audioBufferLength)
            audioMainLeftOff = 0;

        mainAudioLead = audioMainLeftOff - SDL_AtomicGet(&audioCallbackLeftOff);
        if (mainAudioLead < 0)
            mainAudioLead += audioBufferLength;
        //printf("mainAudioLead:%5d\n", mainAudioLead);
        if (mainAudioLead < floatStreamLength)
            printf("An audio collision may have occured!\n");
        SDL_Delay( mainAudioLead*syncCompensationFactor );

*/

    }

    //Free resources and close SDL

    //Free the sound effects
    Mix_FreeChunk( gScratch );
    Mix_FreeChunk( gHigh );
    Mix_FreeChunk( gMedium );
    Mix_FreeChunk( gLow );
    gScratch = NULL;
    gHigh = NULL;
    gMedium = NULL;
    gLow = NULL;

    //Free the music
    Mix_FreeMusic( gMusic );
    gMusic = NULL;

    //Destroy window
    SDL_DestroyRenderer( gRenderer );
    SDL_DestroyWindow( gWindow );
    gWindow = NULL;
    gRenderer = NULL;

    //Quit SDL subsystems
    Mix_Quit();
    IMG_Quit();
    SDL_Quit();

    close();

    return 0;
}
